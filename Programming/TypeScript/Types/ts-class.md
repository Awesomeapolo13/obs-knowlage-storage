
# Class

**Ключи:**
- Обратные:
	- [TypeScript](typescript).

**Хештеги:** 
- #Programming/TypeScript/Types
- #Programming/TS/Types

## Классы и конструктор

Классы - это основные блоки приложений. Во многих языках они являются единственным способом писать код. TS язык мультипредитмальный, т.е. он позволяет писать код используя как функциональный, так и объектно-ориентированный подход. Объявление класса и создание его инстанса выглядят следующим образом:

```typescript
class Coord {  
    lat!: number; // знак ! - не обязательность инициализации свойства (иначе покажет ошибку)
    long: number;  
  
    constructor(lat: number, long: number) {  
        this.lat = lat;  
        this.long = long;  
    }  
}  
  
const point = new Coord(13, 12);
```

Если есть необходимость в необязательной инициализации всех свойств объекта, то лучше избегать отметки `!` после имени свойства. Наиболее подходящее решение - установить свойство `"strictPropertyInitialization": false` в файле `tsconfig.json`

## Наследование

Так же можно наследовать одни объекты от других. При этом необходимо вызвать конструктор родительского класса через специальный метод `super()`.

```typescript
class MapLocation extends Coord {  
    name: string;  
  
    constructor(lat: number, long: number, name: string) {  
        super(lat, long);  // всегда вызывать сразу после конструктора
    }  
}
```

Необходимо вызывать `super()` сразу после конструктора, поскольку всегда сначала отрабатывает конструктор родительского класса, а только потом срабатывают модификации из класса дочернего.

Методы классов при наследовании так же могут быть переопределены. Такие методы называют оверрайд методами. Так же в предпоследней версии TS появилась возможность пометить такой метод ключевым словом `override`. 

```typescript
class MapLocation extends Coord {  
    name: string;  
  
    constructor(lat: number, long: number, name: string) {  
        super(lat, long);  
    }  
  
    override computeDistance(newLat: number, newLong: number): number {  
        console.log(this.name);  
        return 1;  
    }  
}
```

Использование ключевого слова `override` помогает явно указать переопределение некоторого метода и предотвратить (или вовремя обнаружить) ошибки из-за переименовании или удаления родительского метода.

```typescript
interface IUser {  
    name: string;  
    age?: number;  
    bid: <T>(sum: T) => boolean  
}

function bid<T>(sum: T): boolean {  
    return true;  
}
```

## Геттеры и сеттеры

Существеут договоренность, что свойства получаемые и изменяемые через метды геттеры и сеттеры начинаются с символа `_`. Сами же методы нужны, чтобы помещать в них дополнительную логику.

```typescript
class MapLocation extends Coord {  
    _name: string;  
  
    get name() {  
        return this._name  
    }  
  
    set name(name: string) {  
        this._name = name + '_cool'; // Пример доп логики в сеттере
    }
}
```

## Реализация интерфейсов

TS так же позволяет реализовывать интерфейсы. Реализация интерфейсов вместо наследования позволяет не связывать напрямую два класса. Интерфейс своего рода адаптер связывающий несколько классов друг с другом:

```typescript
interface LoggerService {  
    log: (s: string) => void;  
}  
  
class Logger implements LoggerService {  
    log(s: string) {  
        console.log(s);  
    }  
}
```

Сам по себе интерфейс никак не ограничивает реализацию методов. Он задает правила для входных и выходных данных метода.

## Модификаторы

По умолчанию методы классов считаются публичными, однако есть возможность указать это модификатором `public`. 

```typescript
class Logger implements LoggerService {  
    public log(s: string) {  
        console.log(s);  
    }  
}
```

Так же существует модификатор `private` указывающий, что его использование возможно только внутри методов класса; и `protected` - дающий возможность использовать методы в классах наследниках. Кроме того модификаторы могут быть присвоены и свойствам.

Сами же по себе модификаторы существуют лишь до момента компиляции TS в JS. В самом же JS они не существуют.

## Статические методы

В TS так же есть статические методы и классы:

```typescript
class MyClass {  
    static {  
        // Статический блок инициализации  
    }  
    static a = '1'; // статическая переменная  
}

MyClass.a;


```

Как видно из примера выше для использования статических переменных и методов не нужно создавать инстанс класса.

## Джененрики

Чтобы сделать классы более динамическими можно использовать дженерики в свойствах.

```typescript
class MyClass<T> {  
    a: T;  
}  
  
const b = new MyClass<string>();  
b.a;
```


## Абстрактные классы

Абстрактные классы обозначаются ключевым словом `abstract` и в отличие от интерфейсов позволяют делать реализации методов. Однако создать инстанс абстрактного класса невозможно, можно лишь отнаследовать от него другой класс.

```typescript
abstract class Base {  
    print(s: string) {  
        console.log();  
    }  
}  
  
class Realise extends Base {  
  
}  
  
new Realise();
```

Абстрактные классы позволяют задать базовую функциональность, а конкретную реализацию оставить на классы наследники. Например, можно создать абстрактный метод, который будут обязаны реализовать все дочерние классы.

```typescript
abstract class Base {  
    print(s: string) {  
        console.log();  
    }  
  
    abstract error(s: string): void  
}  
  
class Realise extends Base {  
    error(s: string) {  
        console.error(s);  
    }  
}
```

**Ключи:**
- [TypeScript](typescript).

**Хештеги:** 
- #Programming/TypeScript/Types
- #Programming/TS/Types
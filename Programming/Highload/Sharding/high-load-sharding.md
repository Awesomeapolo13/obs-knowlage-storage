
# Шардирование

**Ключи:**
- Обратные:
	- [High load](high-load);
- Прямые:
	- [Партиционирование](high-load-partitioning);
	- [Репликация в MySQL](mysql-replicarion);

**Хештеги:**
- #Highload/Sharding

## Определение

**Щардинг** - вынос части данныъ на другой сервер.

*Вертикальный шардинг* - режем БД потаблично, одну таблицу выноми в отдельную БД.
*Горизонтальный шардинг* - режем одну таблицу (группу таблиц) по определеннуому количеству записей и загружаем эти записи в разные БД.
*Партиционирование* - начальная стадия шардинга.

Необходимость в шардинге появляется, когда мы уже исползовали ниже перечисленные решения:
- Масштабирование чтения - репликация;
- Масштабирование записиси:
	- Вертикальное масштабирование лидера;
	- Оптимизация:
		- по данным - убираем всё лишнее из БД;
		- По настройкам - mysqlture, PGTune и пр.

И если всё уже не помогает, то используем шардинг.

Шардинг оправлывает себя когда:
- Много данных:
	- Много таблиц примерно одинакового и значительного объёма;
	- Таблица с большим количеством записей (медленная выборка даже при использовании индексов);
	- Таблица с большим размером строки:
		- Имеет смысл рассмотреть денормализацию;
- Микросервисная архитектура

## Проблемы

1) Как определить, на какой сервер писать данные?
2) Как определить, с какого сервера читать данные?

## Вертикальный шардинг

Вертикальный шардинг - развитие идеи вертиклаьного партиционирования. По сути это распиливание одной большой БД на несколько меньших.

Приемы реализации:
- Отдельное соединение на каждую БД:
	- Использовать Lazy loading;
- На один шард выделяем взаимосвязанные таблицы:
	- Если нет аткой возможности, то объединение в коде (дозапрашиваем сами) или использовать инвертированный индекс ()

## Горизонтальный шардинг

### Ключ

При выборе первичного ключа необходимо учитывать:
- Равномерность распределения по шардам;
- Количество данных:
	- Хэш для длинных строк;
- Устаревание записей;
- Вычислимость ключа дл выполнения insert.

Для подготовки системы к горизонтальному шардингу:
- подготовить несколько *одинаковых* серверов БД;
- на каждом создаются одинаковые структуры таблиц;
- работа по распределению данных по шардам ложится на приложение;
- данные в больших таблицах нужно разделить по каким то условиям (например с четным id в один щард, нечетные в другой);
- при выборе данных для конкретного пользователя нужно определять в какой шард писать данные (по условию в пункте выше);
- горизонтальный шардинг чаще проводится над одной конкретной таблицей, иначе есть риск потерять связи.

### Функция

Существует разные варианты фунции, определяющей ключ, либо иное правило для определения в какой шард записывать данные (или из какого смотреть).

Например `F(x,n) = y`:
- x - хначение ключа (хэш);
- n - количество серверов;
- y - номер серера.

Варианты функции:
- по целочисленному остатку - делим одно значение на другое, получаем остаток (количество сервреров на что нибудь ещё);
- табличная функция (словарь) - напрямую связываем id новости с номером шарда в некой вспомогательной таблице (в момент создания новости записываем её в рандомный шард).
- бакеты (функция отображает в бакет, а таблица - бакеты в сервера) - они отображают диапазон id, которые идут в тот или иной шард.

![[Pasted image 20240714203500.png]]


### Маршрутизация

1) Должен существовать *умный клиент*, распределяющий что и куда должно идти.
2) Прокси - SPOF - сторонний сервис, делающий то же что и пунктом выше (если на нем зависнет какая то запись, то продук упадет).
3) Дополнительный сервис - SPOF - решает проблемы зависания сообщений в п. выше (хотя и сам может зависнуть).
4) Координатор - SPOF* (можно масштабировать горизонтально) - фиксирует зависания и перезагружает прокси.

## Проблемы при шардинге

### Перебалансировка

Нужна если один из серверов (шардов) несет большую нашрузку чем остальные (возникает узкое место).

Алгоритм:
1) Строим список бакетов, которые требуют переноса в формате (бкет, serverFrom, serverTo)
2) Распространение списка на клиентов
3) Переносятся данные - диапазоны данных переносятся с serverFrom на serverTo
4) Меняем словарь по списку, чтобы знать какие бакеты где находятся.
5) Удаляем список бакетов, оповещаем клиент

Особенности:
1) Read-only mode
	- Запрет на запись на serverFrom в переносимые бакеты на время переноса;
2) Если данные неименяемые, то запрет на запись не нужно
	- Запись на serverTo, чтение с serverTo и serverFrom;
	- Преимущества:
		- Синхронизация мобильных клиентов;
		- Версионность данных;
		- Предсказуемая производительность (произвонимость удет не хуже той что была);
3) Логическая репликация между serverFrom и serverTo
	- Ждем полной синхронизации, работая только с serverFrom, потом переключаемс на serverTo;
	- Новый сервре не используем пока все данные туда не перенесены;

### Решардинг

1) Полное изменние схемы шардинга - его лучше никогда не делать, за исключением шардинга полностью на стороне приложения (в коде).
2) Изменение числа бакетов
	- Номер бакета по остатку от деление;
		- Удваиваем количество бакетов (было 4 бакета, умножаем на 2);
		- Меняем словарь так, чтобы новые бакеты попадалил на старые сервера;
	- Более сложный алгоритм
		- Можем добавлять произвольное количество бакетов и распределяем их как нам кгодно;
		- Реализуется только на стороне приложения;

### Распределенные транзакции

По update:
1) Если данные неизменяемые:
	- Создать объект "транзакция", который содержит данные для записи в бакеты А и В;
	- Запись данных в бакет А
		- Атомарная (в локальной транзакции внутри бакета);
		- Метка транзакции;
		- Если данные уже занесены, то ничего не делаем
	- Запись данных в бакет В (аналогично) - если есть ошибка то откатится ив бакете А и в бакете В;
	- Удаление объекта "транзакция".

Полный алгоритм:
- Необходимо доп. хранилище local_changes, содержит записи вида:
	- Ссылка на объект;
	- Как будет выглядеть объект после успешного завершения транзакции;
	- Ссылка на транзакцию;
- При образении к объектам указываем дополнительно ссылку на транзакцию и проверяем local_changes$
- Транзакции будут содержать два флага:
	- commited = false по умолчанию (если транзакция проходит - становится true);
	- aborted = false  по умолчанию (если транзакция не проходит - становится true);
- Если обращаемся к объекту на чтение:
	- Если local_changes пустой для данного объекта, то возвращаем данные из БД;
	- Если local_changes не пустой для данного объекта, то проверяем состояние транзакции:
		- commited = true - возвращаем данные из local_changes;
		- aborted = true - возвращаем из БД;
		- иначе конфликт - действия зависят от уровня изолированности транзакций.
- Если обращаемся к объекту на запись:
	- Если local_changes пустой для данного объекта, то записываем свои данные и ссылку на свою транзакцию в local_changes;
	- Если local_changes не пустой, проверяем состояние транзакции:
		- commited = true - записываем данные из local_changes в БД, затем записываем свои данные и ссылку на свою транзакцию в local_changes;
		- aborted = true - записываем свои данные и ссылку на свою транзакцию в local_changes;
		- Иначе конфликт - действия зависят от уровня изолированности транзакций
			- Здесь обязательно нужно предусмотреть вариант отмены "висящей" транзакции (aborted = true).

Плный краткий алгоритм:
1) Создаем транзакцию.
2) Обращаемся на запись в бакет А.
3) Образаемся на запись в бакет В.
4) Если транзакция ещё жива, меняем commited = true.
5) Cleanup: проходим по затронутым объектам, и если в local_changes ещё своя транзакция, то применяем изменения и чистим local_changes.
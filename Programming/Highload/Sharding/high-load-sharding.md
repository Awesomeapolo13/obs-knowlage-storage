
# Шардирование

**Ключи:**
- Обратные:
	- [High load](high-load);
- Прямые:
	- [Партиционирование](high-load-partitioning);
	- [Репликация в MySQL](mysql-replicarion);

**Хештеги:**
- #Highload/Sharding

## Определение

**Щардинг** - вынос части данныъ на другой сервер.

*Вертикальный шардинг* - режем БД потаблично, одну таблицу выноми в отдельную БД.
*Горизонтальный шардинг* - режем одну таблицу (группу таблиц) по определеннуому количеству записей и загружаем эти записи в разные БД.
*Партиционирование* - начальная стадия шардинга.

Необходимость в шардинге появляется, когда мы уже исползовали ниже перечисленные решения:
- Масштабирование чтения - репликация;
- Масштабирование записиси:
	- Вертикальное масштабирование лидера;
	- Оптимизация:
		- по данным - убираем всё лишнее из БД;
		- По настройкам - mysqlture, PGTune и пр.

И если всё уже не помогает, то используем шардинг.

Шардинг оправлывает себя когда:
- Много данных:
	- Много таблиц примерно одинакового и значительного объёма;
	- Таблица с большим количеством записей (медленная выборка даже при использовании индексов);
	- Таблица с большим размером строки:
		- Имеет смысл рассмотреть денормализацию;
- Микросервисная архитектура

## Проблемы

1) Как определить, на какой сервер писать данные?
2) Как определить, с какого сервера читать данные?

## Вертикальный шардинг

Вертикальный шардинг - развитие идеи вертиклаьного партиционирования. По сути это распиливание одной большой БД на несколько меньших.

Приемы реализации:
- Отдельное соединение на каждую БД:
	- Использовать Lazy loading;
- На один шард выделяем взаимосвязанные таблицы:
	- Если нет аткой возможности, то объединение в коде (дозапрашиваем сами) или использовать инвертированный индекс ()

## Горизонтальный шардинг

### Ключ

При выборе первичного ключа необходимо учитывать:
- Равномерность распределения по шардам;
- Количество данных:
	- Хэш для длинных строк;
- Устаревание записей;
- Вычислимость ключа дл выполнения insert.

Для подготовки системы к горизонтальному шардингу:
- подготовить несколько *одинаковых* серверов БД;
- на каждом создаются одинаковые структуры таблиц;
- работа по распределению данных по шардам ложится на приложение;
- данные в больших таблицах нужно разделить по каким то условиям (например с четным id в один щард, нечетные в другой);
- при выборе данных для конкретного пользователя нужно определять в какой шард писать данные (по условию в пункте выше);
- горизонтальный шардинг чаще проводится над одной конкретной таблицей, иначе есть риск потерять связи.

### Функция

Существует разные варианты фунции, определяющей ключ, либо иное правило для определения в какой шард записывать данные (или из какого смотреть).

Например `F(x,n) = y`:
- x - хначение ключа (хэш);
- n - количество серверов;
- y - номер серера.

Варианты функции:
- по целочисленному остатку - делим одно значение на другое, получаем остаток (количество сервреров на что нибудь ещё);
- табличная функция (словарь) - напрямую связываем id новости с номером шарда в некой вспомогательной таблице (в момент создания новости записываем её в рандомный шард).
- бакеты (функция отображает в бакет, а таблица - бакеты в сервера) - они отображают диапазон id, которые идут в тот или иной шард.

![[Pasted image 20240714203500.png]]


### Маршрутизация

1) Должен существовать *умный клиент*, распределяющий что и куда должно идти.
2) Прокси - SPOF - сторонний сервис, делающий то же что и пунктом выше (если на нем зависнет какая то запись, то продук упадет).
3) Дополнительный сервис - SPOF - решает проблемы зависания сообщений в п. выше (хотя и сам может зависнуть).
4) Координатор - SPOF* (можно масштабировать горизонтально) - фиксирует зависания и перезагружает прокси.

# Виды репликации

**Ключи:**
- Обратные:
	- [High load](high-load);
	- [Виды репликации](high-load-replication-type);
- Прямые:

**Хештеги:**
- #Highload/Replication 

## По составу участников

![[Pasted image 20240628165021.png]]


1) *Single leader* (Master-Slave, Leader-Follower) - самый простой и популярный механизм, более 80% репликаций выглядит так.
	- Один лидер, много реплик;
	- Из реплик все читают, а обновляют записи только лидера.

![[Pasted image 20240628170238.png]]


2) *Multi leader* - несколько инстансов БД выступают лидером
	- Несколько кластеров single leader + conflict resolver;
	- Может вызывать конфликты;
	- Без конфликт резолвера работать не будет;
	- Система сложная, из-за доп сущности конфлик ресолвера;
	- Может быть вырожденный случай, когда есть лишь лидеры и конфликт резолвер.

![[Pasted image 20240628170417.png]]

3) *Leaderless* - нет лидера совсем
	- Чтобы что-то записать используется алгоритм консенсуса (их может быть много);
	- Таких алгоритмов может быть много, например, все должны быть за (опрашиваем всех, если все согласны - делаем запись) или простое большинство;
	- Устойчив к отключению узлов (мастер упал - все плохо, здесь же, одна упала - остальные договариваются дальше);
	- Блокчейн.

![[Pasted image 20240628170522.png]]

## По гарантии доставки

1) Синхронная (используется редко)
	- Пишем в лидер, но не сразу возвращаем ответ, а спрашиваем реплики;
	- Ждем подтверждения от реплики, только после этого возвращаем ответ источнику;
	- Гарантирует сильную согласованность данных;
	- Медленный ответ.

2) Асинхронная
	- Отвечаем сразу после записи в лидера, подтверждение от реплики приходит позднее;
	- Либо мастер отправляет пуш репликам, либо они сами опрашивают его с какой то периодичностью;
	- Не гарантирует сильной согласованности данных;
	- Гарантирует согласованность в конечном счете;
	- Быстрый ответ.

Рисунок синхронной и асинхронной репликации
![[Pasted image 20240628174139.png]]

3) Семисинхронная
	- В мастер делаетсч запись;
	- Дожидаемся подтверждения от реплик о получении запроса на запись;
	- Отвечаем пользователю после получения подтверждения от всех реплик;
	- Не гарантирует сильную согласованность данных (но не так сильно как асинхронная);
	- Гарантирует согласованность в конечном счете.

## По способу передачи данных

1) Бинарная  - передача файлов журналов.
	- Каждая БД пишет какие то свои журналы и их можено передавать по сети;
	- Нет атомарности (весь файл или ничего).
2) Логическая - передача SQL-команд.
	- На мастере выполнена команда обновления, и затем эту же команду передаем в реплики, где она так же применяется;
	- Атомарность по SQL-командам.
3) Триггеры - для частичной репликации.
	- Позволяет реплицировать не все поля;
	- Используется исчезающе-редко;
	- Атомарность вплоть до значений одного пооля в записи.

## По источнику события передачи данных

1) Push - лидер сам рассылает данные по репликам.
2) Pull - реплики периодически запрашивают обновления.
## Вопросы

1) Что будет с системой лидер + синхронная реплика, если реплика выйдет из строя?
	- Зависит от настройки;
	- Если связка жесткая, то всё упадет;
2) В каких ситуауциях имеет смысл только синхронная репликация?
	- финансовые операции;
	- любые чувствительные данные (за операции с которыми могут наступить юридические последствия);
3) С каким максимальным числом узлов имеет смысл синхронная leaderless репликация?
	- в зависимости от алгоритма будет разное число;
	- в зависимости от доступности БД;
	- если около 10 и более таких реплик то слишком долго ждать ответа и могут быть таймауты;

## Реплика: старт/отказ

Если упала реплика или у нас до этого не было реплик.

1) Загрузка снэпшота базы - снимается бекап с мастера, создаем БД не привязаную к мастеру с этого бекапа.
2) Запросить все данные, начиная с момента последней записи - бекап мог быть снят заранее, нужно догнать мастер (скорее всего мы pull-им данные с него).
3) Записать запрошенные данные.
4) Повторять шаги 2-3, пока не догоним лидера.

## Лидер: старт/отказ

Если отказал лидер.

1) Определить недоступность лидера - убедиться что он упал.
2) Выбрать нового лидера - нет смылся чинить старого, т.к. система уже перестала отвечать на запросы, а это может занять много времени (главное - восстановить работу системы). Процедура не тривиальна, поэтому часто делается вручную.
3) Переконфигруация систем для использования нового лидера - все реплики подключаются к новому лидеру, система снова работает корректно, мы идем чинить старый лидер.

## Типы согласованности

1) **String consistency** (сильная согласованность) - после завершения обновления данных все последующие чтения вернут новые данные. Достигается при синхронной репликации.
2) **Monotonic read/write consistency**- процесс не может получить старое значение после нового или записать значение не в том порядке. Допустим есть пара параллельных процессов, в рамках  одного запроса, если мы пишем новые данные, мы старые не получим, но другой параллельный запрос может.
3) **Weak consistency** (слабая согласованность) - есть окно несогласованности.
	- **Eventual consistency** (согласованность в цонечном счёте) - размер окна несогласованности не фиксирован, зависит от внешних условий;
	- **Casual consistency** (причинная согласованность) - только процессы, уведомленные об обновлениях гарантированно прочитают новые данные;
	- **Read-your-writes consistency** - только сам процесс гарантировано читает обновленные им самим данные;
	- **Session consistency** - процесс получает доступ к хранилищу в рамках сессии.




# Рекурсивные CTE (Common Table Expression)

**Ключи:**
- Обратные:
	- [MySQL](MySQL);
	- [CTE](mysql-cte)
- Прямые:
- [Recursive CTE](mysql-cte-recursive);

**Хештеги:** #Programming/Databases/MySQL/CTE 


## Определение

В MySQL рекурсивное общее табличное выражение (`recursive CTE`) представляет собой именованный временный набор результатов, который ссылается на себя рекурсивно, позволяя выполнять иерархический обход или итерацию по данным до тех пор, пока не будет выполнено указанное условие завершения.

## Синтаксис

Структура рекурсивного `CTE` похожа на обыный `CTE`.

```sql
WITH RECURSIVE cte_name AS (
    initial_query  -- структура привязки (корневой/якорный элемент или anchor member)
    UNION ALL
    recursive_query -- рекурсивный член ссылающийся на имя CTE
)
SELECT * FROM cte_name;
```

Запрос состоит из трех частей:
- Начальный запрос, формирующий базовый набор результатов структуры `CTE`. Начальная часть запроса называется элементом привязки (*anchor member*);
- Рекурсивный запрос — это запрос, который ссылается на имя `CTE`, поэтому он называется рекурсивным элементом. Рекурсивный член соединяется с элементом привязки с помощью оператора `UNION ALL` или `UNION DISTINCT`;
- Условие завершения, которое гарантирует остановку рекурсии, когда рекурсивный член не возвращает строку.

Выполняется рекурсивный `CTE` следующим образом:
1) Сначала разделяет члены на две части: якорные и рекурсивные.
2) Затем выполняется элемент привязки, чтобы сформировать базовый набор результатов (`R0`) и использовать его результаты для следующей итерации.
3) Затем выполняется рекурсивный элемент с набором результатов `Ri` в качестве входных данных и возвращает `Ri+1` результат в качестве выходных данных.
4) После этого третий шаг повторяется до тех пор, пока рекурсивный член не вернет пустой набор результатов, другими словами, пока условие завершения не будет выполнено.
5) В итоге,  наборы результатов от `R0` до `Rn` объединяются, используя оператор `UNION ALL`.

## Ограничения рекурсивных членов

Рекурсивный член не должен содержать следующие конструкции:
- Агрегатные функции, например, `MAX`, `MIN`, `SUM`, `AVG`, `COUNT` и т. д.;
- `GROUP BY`;
- `ORDER BY`;
- `LIMIT`;
- `DISTINCT`.

Следует обратить внимание на то, что приведенное выше ограничение не применяется к элементу привязки (anchor member). Более того, ограничение на использование `DISTINCT` применяется только при использовании оператора `UNION`. Если используется оператор `UNION DISTINCT`, оператор `DISTINCT` разрешен.

Кроме того, рекурсивный член может ссылаться на имя `CTE` только один раз в предложении `FROM`, а не в каком-либо подзапросе.

## Примеры

### Базовый

Ниже приведен пример простейшего рекурсивного `CTE`.

```sql
WITH RECURSIVE cte_count (n) 
AS (
      SELECT 1
      UNION ALL
      SELECT n + 1 
      FROM cte_count 
      WHERE n < 3
    )
SELECT n 
FROM cte_count;
```

Здесь запрос `SELECT 1` является *anchor member*, который возвращает 1 в качестве базового набора результатов.

Запрос:

```sql
SELECT n + 1
FROM cte_count 
WHERE n < 3
```

Это рекурсивный член, потому что он ссылается на имя `CTE` - `cte_count`.

Выражение `n < 3` в рекурсивном члене является условием завершения. Как только `n` станет равным 3, рекурсивный член возвращает пустой набор, который остановит рекурсию.

Подробнее разбиение этого набора можно рассмотреть ниже:

![[Pasted image 20240821113411.png]]

Этапы выполнения рекурсивного `CTE` следующие:
- сначала разделяется якорные и рекурсивные члены;
- затем элемент привязки формирует начальную строку (`SELECT 1`), поэтому первая итерация дает `1 + 1 = 2` с `n = 1`;
- затем вторая итерация оперирует выходными данными первой итерации (`2`) и выдает `2 + 1 = 3` с `n = 2`;
- после этого перед третьей операцией (`n = 3`) выполняется условие завершения (`n < 3`), поэтому запрос останавливается;
- наконец, все наборы результатов `1`, `2` и `3` объединяются с помощью оператора `UNION ALL`.

### Обход иерархических данных

Допустим у нас есть таблица ниже:

```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    employee_name VARCHAR(50),
    manager_id INT
);
```

Тогда объод иерархической структуры будет выглядеть так:

```sql
WITH RECURSIVE EmployeeHierarchy AS (
    SELECT
        employee_id,
        employee_name,
        manager_id,
        0 AS level
    FROM
        employees
    WHERE
        manager_id IS NULL -- Anchor member (root of the hierarchy)
        
    UNION ALL
    
    SELECT
        e.employee_id,
        e.employee_name,
        e.manager_id,
        eh.level + 1
    FROM
        employees e
    INNER JOIN
        EmployeeHierarchy eh ON e.manager_id = eh.employee_id -- Recursive member
)
-- Final query to select from the CTE
SELECT
    employee_id,
    employee_name,
    manager_id,
    level
FROM
    EmployeeHierarchy
ORDER BY
    level, employee_id;
```

Работа запроса:
- определяется `CTE` с именем `EmployeeHierarchy`;
- определяется элемент привязки, который выбирает сотрудников, у которых нет менеджера (`manager_id IS NULL`), начиная с корня иерархии (`CEO`);
- рекурсивный элемент соединеняет таблицы сотрудников с `CTE` при условии, что идентификатор менеджера в таблице сотрудников соответствует идентификатору сотрудника в `CTE`, эффективно передавая иерархию;
- выбирается информацию из `CTE`, включая идентификатор сотрудника, имя, идентификатор руководителя и уровень иерархии в окончательном запросе. Набор результатов сотируется по уровню и идентификатору сотрудника.

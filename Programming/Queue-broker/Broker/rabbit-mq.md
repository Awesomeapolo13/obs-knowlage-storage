
# RabbitMQ

**Связи:**
- Обратные
	- [Брокеры очередей](queue-broker);
- Прямые:
	- [Доставка сообщений rabbit](rabbit-messaging);
	- [Обработка сообщений rabbit](rabbit-message-handling);
	- [RabbitMQ cluster](rabbit-cluster);
	- [RabbitMQ federation](rabbit-federation);

**Хештеги:**
- #Queue/Broker ;
- #Rabbit

## Определение

**RabbitMQ** -  это распределенная система управления очередью сообщений. Распределенная, поскольку обычно работает как кластер узлов, где очереди распределяются по узлам и, опционально, реплицируются в целях устойчивости к ошибкам и высокой доступности.

Диспетчеризация - основная killer фича rabbit.

## Особенности

1) Гибкая маршрутизация
	- можно даже в рантайме менять маршруты;
	- нужно понимать, что если в очереди что-то уже лежит, то не зависимо от изменения маршрута оно никуда оттуда не денется;
2) Гарантия либо *at-most-once delivery*, либо *at-least-once-delivery*:
	- нельзя добиться, чтобы каждое наше сообщение было доставлено лишь один раз;
	- можем требовать, либо гарантированной доставки *at-least-once-delivery* (т.е. сообщения будут теряться, но контроль за дублями на нас);
	- или же, чтобы сообщение всегда доставлялось лишь один раз, но тогда оно может потеряться (*at-most-once delivery*);
	- желательно выбрать одну стратегию на всё приложение, чтобы не путаться потом.
3) Реализует Push-стратегию:
	- балансировку надо настраивать на стороне rebbit;
4) Не гарантирует порядок доставки при параллельной обработке "из коробки":
	- нужно использовать дополнительный вспомогательный функциона (он в нем есть).

## Реализация

### Составляющие

1) Сообщение (Message) - единица передаваемая через rebbit.

![[Pasted image 20240617102729.png]]

2) Поставщик (Producer / Publisher) - тот кто отправляет сообщение.
3) Подписчик (Consumer / Subscriber) - тот кто получает сообщение.
4) Очередь (Queue) - место где хранятся сообщения, здесь они материализуются, фиксируются.
5) Точка обмена (Exchange) - отличительная особенность *RabbitMQ*, механизм, с помощью которого осуществляется гибкая маршрутизация. В Точке обмена сообщение не хранится, оно просто проходит через неё, к нему применяется некая логика (если сообщение попало в Exchange и вырубилось электричество, то оно нам пропадет).

### Отправка сообщений

1) Поставщик публикует сообщение в Exchange:
	- некий процесс php передает сообщение поставщику;
	- он публикует сообщение в точку обмена;
	- можно обойти точку обмена и сразу отправить в очередь, но если нам не нужна маршрутизация, то зачем нам вообще RabbitMQ;
2) Точка обмена, получив сообщение, распространяет его на один уровень:
	- это может быть как очередь, так и другие точки обмена (их может быть несколько);
	- exchange отвещает поставщику, что сообщение отправлено, все ok , но никаких гарантий, что оно отправлено именно в очередь или получено подписчиком нет (подтверждение отправки на один уровень дальше, что это за уровень мы не знаем);

### Получение сообщений

1) Подписчик сообщает RabbitMQ, какую очередь он слушает:
	- подписчик - отдельное консольное php приложение;
	- он подключается к rabbit и сообщает какую очередь он будет слушать (какую очередь, которая слушает точку обмена с некоторыми параметрами);
	- rabbit проверяет, есть ли такая очередь (если её нет, то создает её);
	- проверает есть ли подписка на указанную точку обмена (если её нет, то создает её);
2) RabbitMQ делает push сообщений в очередь (как только они появляются).
3) Подписчик возвращает ответ (целое число).
4) Если ответ успешный, то сообщение удаляется из очереди, иначе возвращается обратно (если такой флажок указан).

Возможны разные конфигруации.

1) Например, независимые подписчики:

![[Pasted image 20240617104823.png]]

Новостные порталы публикуют новости, а каждый из агрегаторов сам решает нужна ему эта новость или нет. Выборка на стороне Consumer, каждый Publisher и Consumer это независимое приложение (возможно принадлежащие разным компаниям).

Один портал публикует новость, она попадает в точку обмена, в каждую из очередей попадает копия этого сообщения. Каждый подписчик отдельно получит и обработает это сообщение.

2) Конкурирующие подписчики

![[Pasted image 20240617105936.png]]

Возникает когда один подписчик не справляется, мы добавляем ему потоков. Принципиальная разница с независимыми подписчиками - количество очередей. Конкурирующие подписчики слушают одну очередь. Т.к. rabbit реализует push стратегию, не подписчик выбирает когда ему получить сообщение, а rabbit сам проталкивает в подписчик то сообщение, которое считает нужным. В этот момент может нарущиться порядок.

3) Смешанный вариант.

![[Pasted image 20240617110502.png]]

Каждую очередь слушает одно кокретное приложение, но оно может обрабатывать очередь в несколько потоков. По умолчанию баланчировка будет round robin.

### Типы точек обмена

1) **Fanout** - разветвление. Сообщения копируются во все точки обмена и очереди, привязанные к точке обмена.

Основная killer фича rabbit - диспетчеризация, т.е. мы хотим точно указать какие сообщения в какие очереди могут попасть, а какие нет. Это достигается благодаря протоколу AMQP. Мы добавляем сообщению некие метаданные, например, *ключ маршрутизации* (`routing_key`). Есть несколько вариантов бизнес-логики, для обработки ключа маршрутизации.

2) **Direct** - прямая связь. Маршрутизация по точному соотетствию ключа маршрутизации (`routing_key`). Т.е. с сообщением передаем ключ маршрутизации, и далее сообщение пропускается в те очереди, где совпадают эти ключи. Например, указать в ключе тип новости. Одна очередь, может принимать несколько разных ключей маршрутизации.
3) **Topic**  - тематическая. Аналог Direct с проверкой на частичное соответствие ключа маршрутизации. Точно знает что-то про внутреннюю структуру ключа маршрутизации. Ключ разделяется точками `LEVEL.AppName` (`LEVEL` - уровень логирования). При этом в плейсхолдерах `*` - одно слово, `#` - любое количество слов (`*.ECommerceSite.WebUI`, `ERROR.#`, `#` - слушает всё).

![[Pasted image 20240617125657.png]]

Лучше в конце ключа указывать `#`, чтобы предусмотреть дальнейшее развитие ключа на несколько уровней ниже. Единственный побочный эффект, мы возможно будем получать несколько больше сообщений, но это лучше чем совсем не получить их при использовании `*`.

4) **Header** - заголовочный. К сообщениям добавляются заголовки получателей, требуется точное соответствие заголовков.
5) **Consistent Hashing** - консистентное хэширование. Очередь выбирается по хэшу. Используется через плагин к RebbitMQ. Используется для решения проблемы конкурирующих консюмеров и последовательностей обработки сообщений.




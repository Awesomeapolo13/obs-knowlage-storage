
# Apache Kafka

**Связи:**
- Обратные
	- [Брокеры очередей](queue-broker);
- Прямые:

**Хештеги:** 
- #Queue/Broker ;
- #Kafka

## Особенности

1) В чистом виде, это не брокер сообщений. Это распределенный, реплицированный commit log, т.е. есть несколько экземпляров, так же есть несколько их копий (несколько серверов, которые дублируются), мы туда что-то пишем и оно не должно пропадать. Это позволяет использовать кафку как брокер сообщений, но нужно периодически чистить от туда эти сообщение.

2) Благодаря этому, есть возможность "перемотки назад". Пока сообщение не удалено, к нему можно вохвращаться (в отличие от RabbitMQ). Может быть важно, если важен порядок обработки сообщений, можно вернуться назад, откатить правки и сделать все заново. Далеко назад вернуться не получится, лишь на несколько сообщений.

3) Pull тсратегия. Для php kafka интегрируется достаточно низкоуровнево, существует не очень много библиотек (есть расширение и некоторые не очень полные библиотеки). Вся ответственность лежит на читателе. Kafka не позволяет многократно, в рамках одного приложения, выбрать одно и то же сообщение.

4) Гарантирует порядок доставки при параллельной обработке (но не глобально). В kafka есть несколько хранилищь, в рамках одного хранилища порядок будет фиксирован, а в глобальном нет (если пишем в несколько хранилищь, порядок может быть нарушен).

## Реализация

### Составляющие

1) Запись (Record) - единица передаваемая через kafka.
2) Поставщик (Producer) - тот кто отправляет запись.
3) Подписчик (Consumer) - тот кто отправляет получает.
4) Категория (Topic) - куда пишем запись.
5) Позиция записи/чтения (Offset) - продюсер имеет свой офсет, консюмеры имеют свои офсеты, разница между офсетами разных консюмеров, читающиходин и тот же топик, называется Consumer lag.

![[Pasted image 20240617134753.png]]

Каждый консюмер сам спрашивает у kafka следующее сообщение. При этом можно переопределять офсеты консюмеров, но по умолчанию kafka помнит офсеты для каждого консюмера.

### Группы консюмеров

В rabbit можно в рантайме убирать и добавлять консюмеры, очереди и прочее.
В kafka у каждого топика есть некоторое количество партиций, ограничивающее количество консюмеров, которые могут одновременно читать этот топик. Не может быть ситуации, когда два консюмера одного приложения читают одну и ту же партицию топика. Один и тот же топик можно, но тогда разные партиции. Нет запрета чтобы один консюмер читал разные топики.

![[Pasted image 20240617135558.png]]

На рисунке выше нельзя добавить ещё один консюмер читающий топик А в группу А, т.к. в топике А всего три партиции. Т.е. 3 партиции = 3 консюмера.

Для выполнения перебалансировки в kafka, как минимум придется идти на сервер kafka и выполнять консольную команду. Т.е. если заранее не предусмотреть нужное количество партиций, то в рантайме быстро их добавить не получится.

### Консьюмеры и партиционирование

Kafka не гарантирует глобальную очередность. В момент, когда мы добавляем консьюмеры происходит перебалансировка.

![[Pasted image 20240617155716.png]]

В Original state у нас было три консьюмера, которые брали данные как указано на рисунке.
Далее мы добавили ещё два консьюмера. И kafka перебалансировала систему, чтобы каждый консьюмер читал записи из одной партиции. Это рушит установленный ранее порядок чтения, консьюмеры начинают читать не свои партиции. Так же съедут офсеты, т.к. kafka помнит лишь про офсет группы, т.е. если C2 не успеет обработать запись из партиции 3, оно может быть никогда не обработано и будет нарушен порядок.

Поэтому важно самому назначать какие партиции консьюмерам слушать, иначе kafka всё переключит сам.
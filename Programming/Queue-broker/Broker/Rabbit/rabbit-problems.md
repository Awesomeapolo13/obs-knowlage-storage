
# Проблемы RabbitMQ

**Связи:**
- Обратные
	- [RabbitMQ](rabbit-mq.md);
- Прямые:

**Хештеги:**
- #Queue/Broker ;
- #Rabbit 

## Соединения

Раббит очень требовательный. Со старта для публикацииодного сообщения нужно потратить 7 пакетов + 3 (amqps) на открытие соединения, еще 2 для открытия канала и 1 на публикацию сообщения (всего от 10 до 13 пакетов). Но так же может потребоваться +1 для создания очереди, +1 для создания dlx очереди (очередь для повторной публикации сообщений).

Ребит не любит множественные соединения и каналы, при большом их объеме он начинает деградировать. Поэтому если мы не можем повторно использовать соединения и каналы, мы должны использовать прокси.

Прокси ставятся перед продюссером, они могут аггрегировать множество соединений и каналов в одно для кролика. Так же нужно определиться куда прокси ставить. Можно поставить прокси перед каждым продюссером, либо один прокси перед всеми продюссерами. В последнем случае улучшается статистика соединений и подключений (но если прокси упадет то все продюссеры станут недоступны).

Так же в реббите существует flow-control механизм для защиты от перегрузки, когда быстрый продюссер публикует большой поток сообщений. В этом случае реббит искуственно замедляет продюссер. Если у нас в приложении есть и продюссер и консюмер и они пользуются одним соединением, то консюмер перестанет получать сообщения (т.е. они должны пользоваться и разными каналами и разными соединениями). 

Рекомендуется ставить amqproxy для фреймворком Symfony и Laravel, т.к. у них нет роадраннер и они могут насоздавать соединений и каналов. Для Spiral это не требуется.

## Публикация

Поскольку в php умирающая модель, фреймворки не знают о том существует очередь или нет. Поэтому перед каждой публикацией они создают её заново, что увеличивает нашу латентность и латентность запросов к кролику (время подготовки перед публикацией сообщений).

В Symfony можно в настройках транспорта указать auto_setup: false, тогда фреймворк не будет пытаться создать очередь пере каждой публикацией. Но в комманду деплоя нужно будет добавить консольную команду `php bin/console messenger:setup-transports` для создания очередей.

В Laravel нельзя отключить это поведение, плюс используется отдельный канал для создания очереди. Что вызывает сильный рост количества каналов.

Spiral - создает один раз, т.к. роадраннер не умирает.

## Гарантии доставки

По умолчанию AMQP использует failing forget model, т.е. мы вообще не знаем попало сообщение в очередь и никакой отбивки от реббита не получаем.  Для решения этой проблемы есть транзакции, но как и любые транзакции, они медленные.

В реббите есть рассширение AMQP протокола - publisher-confirms. После этого канал переходит в режим подтверждения, из-за чего перестают работать транзакции, но на каждый паблиш будем получать от кролика frame basic.ack. Производительность несколько падает, но кроллик может группировать подтверждения, например отправлять их на каждое 10-е или 100-е. В basic.ack будет передан флаг multiple и деливери тег последнего сообщения, до которого мы считаем сообщения подтвержденными.

В Symfony можно настроить опцию confirm_timeout в секундах. Через это время мы получим подтверждения  от кролика.

По умолчанию кролик использует паттерн Шина событий, поэтому подтверждения публикации в очередь может быть недостаточно. Ведь в шине событий нормально не иметь получателя. Если же при публикации передать флаг mandatory: true, тогда до basic.ack кролик проверит существует ли такая очередь, если не существует вернет basic.return (возвращается до basic.ack).

По умолчанию реббит использует delivery_code=1 (transient), т.е. он сохраняет все сообщения в памяти. В этом случае при падении кролика после basic.ack, мы потеряем сообщение (оно не успеет сохраниться в памяти). Для решения проблемы устанавливаем delivery_code=2 (persistent), что скажет кролику сохранять сообщения на диске и только после этого возвращать ответ. Тогда после падения кролик возмет сообщения с диска.

Если некуда отправить сообщения, можно прикрепить к нему альтернативный обменник (alternate exchange), и он будет собирать сообщения, которые некуда доставить. Например, после падения, продюсер может подняться первым и уже начать публиковать сообщения, а консюмер еще лежит и не создал очередь. Часть сообщений могут быть потеряны. Тогда мы создаем alternate exchange, прикрепляем к нему очередь, указываем ей TTL. После истечения TTL сообщения вновь перейдут в основной обменник.

![[Pasted image 20250426164727.png]]


## Хранение сообщений

Популярный паттерн использования кролика dead letter queue. Это такие очереди, в которых мы некоторое время храним сообщения, которые не можем обработать. Эти очереди очень полные, и сообщения он хранит в памяти. До версии 3.12 эти очереди нужно создавать с флагом lazy, тогда сообщения будут храниться на диске, а не в буфере. Признак persistent не противоречит lazy и их нужно использовать совместно, т.к. один влияет на гарантии доставки, а другой на то как будут храниться сообщения до того, как попадут к консюмерам.

В Symfony можно указать queue-mode: lazy, но только для основных очередей. Для dead letter всё захардкожено. 

После версии 3.8 появились кворумные очереди. Это такой вид очередей, который предлагает нам улучшенные настройки хранения и гарантий. В них, для уменьшения количества сообщений хранимых в памяти, нужно указать x-max-in-memory-length. Кворумы можно включать во всех крупных пхп фреймворках. 

![[Pasted image 20250426165555.png]]

Если нужны производительные очереди: выбираем классические зеркалированные, но до 4-й версии (потом их удалили).
Если нужны надежные очереди: выбираем кворумные.

## Повторная обработка

Все фреймворки совершают одну и ту же ошибку. Они дают пользователю выбирать TTL на повторную обработку сообщений. Это приводит к тому, что каждый раз, когда мы хотим повторить сообщение, мы совершаем три команды: опубликовать новую очередь (т.к. очереди для повторного отправления expirable), паблиш и акт. Три нетранзакционные команды, две из которых влияют на то, чем мы жертвуем (либо идемпотентностью, либо гарантиями единственной доставки).

![[Pasted image 20250426170433.png]]

При этом всём фреймворки начинают наполнять сообщения служебной информацией в виде трейсов, ретраев и прочми. Они начинают весить очень много.

Правильно - заранее готовиться к ошибкам. Создавать фиксированные топологии с объявленными очередями для ошибок.  В этом случае достаточно одной атомарной команды nack, чтобы отправить сообщение в этму очередь.

![[Pasted image 20250426171411.png]]

Необходимо обязательно указывать параметр requeue:fasle, иначе он отправит сообщение в голову очереди а не в хвост. Это может привести к бесконечному циклу в начале очереди и она просто встанет. 

Так же есть плагин rabbitmq-delayed-message-exchange, он позволяет создать один обменник для всех таких сообщений, но сильно страдает от лага таймера. Сравнительный анализ ниже (dynamic dlx - это подход фреймворков по умолчанию, static dlx - то что обсуждали перед плагином).

![[Pasted image 20250426171944.png]]

## Получение сообщений

В кролике существует два подхода.

Первый - это basic.get или pull подход - сами ходим к кролику за собщениями (пул стратегия), периодические обращения создают сильную нагрузку на кролика.
Второй способ basic.consume  или push - тогда кролик посылает сообщения сам. Это помогает нам обрабатывать сообщения пачками (batch). Мы отправляем qos(3), в скобках указано количество сообщений в пачке, дожидаемся когда там приходят эти три сообщения и затем отвечаем ack(multiple), после чего кролик удалит все три сообщения. 

![[Pasted image 20250426173642.png]]

![[Pasted image 20250426173718.png]]


## Множественная обработка

Это когда мы одно событие хотим обработать несколькими обработчиками. В Symfony количество обработчиков не влияет на количество публикуемых сообщений.  У ларавель будет две очереди.

Правильно же будет сделать так:
1) Создать обменник
2) Отправить сообщения из обменника в две разные очереди.
3) Настроить заранее топологию для каждой очереди.

![[Pasted image 20250426175757.png]]

## Итоги

### По продюсерам

1) Используем amqproxy
2) Используем механизмы роутинга во избежание нарушения идемпотентности и потери сообщений
3) Используем publisher confirms + persistent + (mandatory + alternate exchange)
4) Используем quorum
5) Используем возможность заранее создавать очереди на этапе деплоя

### По консюмерам

1) Используем статические dlx
2) Используем lazy для dlx
3) Используем basic.consume вместо basic.get
4) Следим за prefetch count
5) Используем БД, если нужно много разных ретраев
6) Используем заголовки RabbitMQ для отслеживания количества аоаыток и их лимиты
7) Не делаем жирные сообщения

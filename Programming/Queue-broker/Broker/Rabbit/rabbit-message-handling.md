# Обработка сообщений

**Связи:**
- Обратные
	- [RabbitMQ](rabbit-mq.md);
- Прямые:

**Хештеги:**
- #Queue/Broker ;
- #Rabbit 

## Общие сведения

В протоколе AMQP 0-9-1 существует два пути обработки сообщений приложением:

- подписка на доставку сообщений («push API»): это рекомендуемый вариант;
- опрос (polling - «pull API»): этот способ крайне неэффективен, и его в большинстве случаев следует избегать.

С помощью «push API» приложения должны указывать на заинтересованность в получении сообщений из определенной очереди. Когда они это делают, мы говорим, что они *регистрируют потребителя (consumer, консьюмер, читатель)* или, проще говоря, *подписываются на очередь*. Для каждой очереди можно подключать более одного консьюмера или зарегистрировать эксклюзивного (exclusive) консьюмера (исключающего всех остальных из очереди во время потребления).

Каждый потребитель (подписка) имеет идентификатор, называемый тегом потребителя. Его можно использовать для отказа от подписки на сообщения. Потребительские теги — это просто строки.

## Подтверждение сообщений

**Приложение читатель (Consumer application)** - это приложение, которое получает и обрабатывает сообщения. Оно может внезапно упасть, в процессе обработки конкретного сообщения, потери соединения с сервером или по иным причинам.

Это вызывает вопрос: Когда необходимо удалять сообщения из очереди? Спецификация AMQP 0-9-1 дает читателям контроль над этим процессом. Существует два режима подтверждения:

- после того, как брокер отправляет сообщение приложению (используя метод Basic.deliver или Basic.get-ok);
- после того, как приложение отправит обратно подтверждение (с использованием метода Basic.ack).

Первый вариант называется *моделью автоматического подтверждения (automatic acknowledgement model)*, а второй — *моделью явного подтверждения*. При использовании явной модели приложение выбирает время отправки подтверждения. Это может быть сразу после получения сообщения, или после сохранения его в хранилище данных перед обработкой, или после полной обработки сообщения (например, успешного получения веб-страницы, ее обработки и сохранения в каком-либо постоянном хранилище данных).

Если читатель умирает, не отправив подтверждение, брокер повторно доставит его другому читателю или, если ни один из них в данный момент недоступен, брокер будет ждать, пока хотя бы один потребитель не будет зарегистрирован в той же очереди, прежде чем пытаться выполнить повторную доставку.

## Отклонение сообщений

Если обработка сообщения не удалась по каким то причинам, то приложение может воспользоваться механизмом отклонения сообщения (rejecting messages). Приложение может попросить брокер убрать сообщение или повторно отправить его в очередь. Если используется только один читатель на очередь, убедитесь, что не создается бесконечных циклов доставки сообщений, которые снова и снова отклоняют сообщение от одного и того же читателя.

## Отрицательные подтверждения

Сообщения отклоняются с помощью метода `basic.reject`. У `basic.reject` есть одно ограничение: невозможно отклонить несколько сообщений, как это можно сделать с подтверждениями. Однако RabbitMQ предоставляет расширение для AMQP 0-9-1, известное как отрицательные подтверждения (negative acknowledgements) или *nack*.

## Предварительная загрузка сообщений

В случаях, когда несколько потребителей совместно используют очередь, полезно иметь возможность указать, сколько сообщений каждый потребитель может отправить одновременно, прежде чем отправлять следующее подтверждение. Это можно использовать как простой метод балансировки нагрузки или для повышения пропускной способности, если сообщения имеют тенденцию публиковаться пакетами. Например, если производящее приложение отправляет сообщения каждую минуту из-за характера выполняемой им работы.

Обратите внимание, что RabbitMQ поддерживает только подсчет предварительной выборки на уровне канала, а не предварительную выборку на основе соединения или размера.

## Особенности

Читатель (Consumer) всегда медленный и нам нужно заставить его работать как можно быстрее. 

![[Pasted image 20240618104744.png]]

По умолчанию используется средний вариант. Т.е. мы на каждое сообщение из реббита отвечаем, что забрали его и можно удалить это сообщение.

Можно сохранять сообщение в БД и использовать далее для транзакций.

Можно пушить сообщения непрерывным потоком.

QoS (Quality of service) - если повысить его значение, создает периоды латентности, позволяющие протолкнуть за раз значительное количество сообщений. При этом ломает порядок обработки сообщений. Лучше использовать с механизмом согласованного хеширования или просто добавить консьюмеров вместо QoS. QoS выставляется руками на каждый конкретный консьюмер.

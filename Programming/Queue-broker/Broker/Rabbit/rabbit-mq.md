
# RabbitMQ

**Связи:**
- Обратные
	- [Брокеры очередей](queue-broker);
- Прямые:
	- [Доставка сообщений rabbit](rabbit-messaging.md);
	- [Обработка сообщений rabbit](rabbit-message-handling.md);
	- [Точка обмена (Exchange)](rabbit-exchange);
	- [Очередь](rabbit-queue);
	- [Привязки](rabbit-bindings);
	- [Сообщения](rabbit-message);
	- [RabbitMQ cluster](rabbit-cluster.md);
	- [RabbitMQ federation](rabbit-federation.md);
	- [Проблемы](rabbit-problems);

**Хештеги:**
- #Queue/Broker ;
- #Rabbit

## Определение

**RabbitMQ** -  это распределенная система управления очередью сообщений. Распределенная, поскольку обычно работает как кластер узлов, где очереди распределяются по узлам и, опционально, реплицируются в целях устойчивости к ошибкам и высокой доступности.

Диспетчеризация - основная killer фича rabbit.

## Особенности

1) Гибкая маршрутизация
	- можно даже в рантайме менять маршруты;
	- нужно понимать, что если в очереди что-то уже лежит, то не зависимо от изменения маршрута оно никуда оттуда не денется;
2) Гарантия либо *at-most-once delivery*, либо *at-least-once-delivery*:
	- нельзя добиться, чтобы каждое наше сообщение было доставлено лишь один раз;
	- можем требовать, либо гарантированной доставки *at-least-once-delivery* (т.е. сообщения будут теряться, но контроль за дублями на нас);
	- или же, чтобы сообщение всегда доставлялось лишь один раз, но тогда оно может потеряться (*at-most-once delivery*);
	- желательно выбрать одну стратегию на всё приложение, чтобы не путаться потом.
3) Реализует Push-стратегию:
	- балансировку надо настраивать на стороне rabbit;
4) Не гарантирует порядок доставки при параллельной обработке "из коробки":
	- нужно использовать дополнительный вспомогательный функциона (он в нем есть).

Его стоит использовать если:
- нужна сложная маршрутизация;
- средние объемы сообщений, до 50k/сек (для высоких нагрузок, якобы, не справляется);
- команда хочет простоты;
- нужен удобный мониторинг;
- критичны гарантии доставки.

## Реализация

### Составляющие

1) Сообщение (Message) - единица передаваемая через rebbit.

![[Pasted image 20240617102729.png]]

2) Поставщик (Producer / Publisher) - тот кто отправляет сообщение.
3) Подписчик (Consumer / Subscriber) - тот кто получает сообщение.
4) Очередь (Queue) - место где хранятся сообщения, здесь они материализуются, фиксируются.
5) Точка обмена (Exchange) - отличительная особенность *RabbitMQ*, механизм, с помощью которого осуществляется гибкая маршрутизация. В Точке обмена сообщение не хранится, оно просто проходит через неё, к нему применяется некая логика (если сообщение попало в Exchange и вырубилось электричество, то оно нам пропадет).

### Отправка сообщений

1) Поставщик публикует сообщение в Exchange:
	- некий процесс php передает сообщение поставщику;
	- он публикует сообщение в точку обмена;
	- можно обойти точку обмена и сразу отправить в очередь, но если нам не нужна маршрутизация, то зачем нам вообще RabbitMQ;
2) Точка обмена, получив сообщение, распространяет его на один уровень:
	- это может быть как очередь, так и другие точки обмена (их может быть несколько);
	- exchange отвещает поставщику, что сообщение отправлено, все ok , но никаких гарантий, что оно отправлено именно в очередь или получено подписчиком нет (подтверждение отправки на один уровень дальше, что это за уровень мы не знаем);

### Получение сообщений

1) Подписчик сообщает RabbitMQ, какую очередь он слушает:
	- подписчик - отдельное консольное php приложение;
	- он подключается к rabbit и сообщает какую очередь он будет слушать (какую очередь, которая слушает точку обмена с некоторыми параметрами);
	- rabbit проверяет, есть ли такая очередь (если её нет, то создает её);
	- проверает есть ли подписка на указанную точку обмена (если её нет, то создает её).
2) RabbitMQ делает push сообщений в очередь (как только они появляются).
3) Подписчик возвращает ответ (целое число).
4) Если ответ успешный, то сообщение удаляется из очереди, иначе возвращается обратно (если такой флажок указан).

Возможны разные конфигруации.

1) Например, независимые подписчики:

![[Pasted image 20240617104823.png]]

Новостные порталы публикуют новости, а каждый из агрегаторов сам решает нужна ему эта новость или нет. Выборка на стороне Consumer, каждый Publisher и Consumer это независимое приложение (возможно принадлежащие разным компаниям).

Один портал публикует новость, она попадает в точку обмена, в каждую из очередей попадает копия этого сообщения. Каждый подписчик отдельно получит и обработает это сообщение.

2) Конкурирующие подписчики

![[Pasted image 20240617105936.png]]

Возникает когда один подписчик не справляется, мы добавляем ему потоков. Принципиальная разница с независимыми подписчиками - количество очередей. Конкурирующие подписчики слушают одну очередь. Т.к. rabbit реализует push стратегию, не подписчик выбирает когда ему получить сообщение, а rabbit сам проталкивает в подписчик то сообщение, которое считает нужным. В этот момент может нарущиться порядок.

3) Смешанный вариант.

![[Pasted image 20240617110502.png]]

Каждую очередь слушает одно кокретное приложение, но оно может обрабатывать очередь в несколько потоков. По умолчанию баланчировка будет round robin.

## Паттерны

1) Шина команд
2) Шина событий
3) Request/Reply
4) Календярь задач



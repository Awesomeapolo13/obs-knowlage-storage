
# Брокеры очередей


**Связи:**
- Обратные
	- [Программирование](PROGRAMMING);
- Прямые:
	- [RabbitMQ](rabbit-mq.md);
	- [Apache Kafka](apache-kafka.md);

**Хештеги:** #Queue/Broker 

## Определение

Брокер сообщений

Помогает организовывать такую структуру как очередь для решения следующих задач:

- буферизация  - быстрый писатель / медленный читатель (много запросов, их надо куда то сложить и потом постепенно обработать);
- транспорт - унификация протокола передачи сообщений;
- диспетчеризация маршрутов обработки задач (сообщений);
- балансировщик.

## Особенности очередей

Преимущества:
- слабая связанность между отправителем и получателем (только по телу сообщений);
- гибкость настроки маршрутов передачи сообщений;
- фиксированный порядок обработки (но есть нюансы, в зависимости от брокера).
Недостатки:
- потеря сообщений;
- многократная доставка сообщений;
- доп точка отказа.

## Зачем нужно отдельное ПО для очередей

- Не все языки программирования могут реализовать очереди внутри себя, т.к. для сообщений нужно хранилище;
- Можно конечно исползовать БД как хранилище, но опять же это внешнее хранилище;

## Проблемы

- Многократная реакция на сообщение (придется в коде обрабатывать такие случаи, например присваивать событиям `id`);
- "Убийственные" задачи - каждое задание может содержать внутри, что угодно (можно послать одно писмо на 1 email, а следующее на 100), т.е. если у нас один слушатель и читатель, то сообщения могут долго лежать в очереди ожидая пока он обработает задачу (нужно формировать очереди так, чтобы каждое сообщение в каждой очереди обрабатывалось примерно одинаково по времени);
- Зависание обработчиков - зависание при обработке сообщений, например, бесконечный цикл в коде или нужно опросить другие сервисы с большими таймаутами;
- Персистентность сообщений - сообщения висят в памяти, если вырубить брокер сообщений, они пропадут без следа (нужно разработать механизм персистентности, если это нужно).

## Реализация

Брокер не выполняет никаких заданий, его цель донести сообщение до получателя, чтобы тот уже это задание выполнил.

**Какие варианты:**
- Своя реализация (некий общий ресурс, код будет в него сохранять сообщения);
- БД как хранилище, но нужно решать вопросы балансировки, плюс проблемы с конкурентным доступом;
- Внешний брокер:
	- RabbitMQ (популярен в PHP);
	- Redis (Pub/Sub);
	- Apache Kafka (популярна в Java жкосистеме);

**Стратегия релизации:**
1) **Push** - брокер сам присылает сообщения (тонкий клиент, не нужно ничего спрашивать);
2) **Pull** - приложение само спрашивает у брокера, если ли новые сообщения (более толстый клиент, придется все время спрашивать).

**Отказоустойчивость vs масштабирование** - при масштабировании читателей возникает много вопросов, связанных с правильным порядком обработки этих сообщений, т.е. при масштабировании читателей мы понижаем вероятность того, что система ведется себя так как мы задумали.

**Протоколы:**
- *STOMP (Simple Text Oriented Message Protocol)* - простой, самый первый, и уже почти не используется;
- *MQTT (Message Queue Telemetry Transport)* - часто используется в интернете вещей и embedded устройствами;
- *AMQP (Advanced Message Queueing Protocol)* - наиболее популярный, используется большинством брокеров.
	- *AMQP 0-9-1 (расширенный протокол очереди сообщений)* — это протокол обмена сообщениями, который позволяет соответствующим клиентским приложениям взаимодействовать с соответствующими брокерами промежуточного программного обеспечения обмена сообщениями;
	- *AMQP 1.0* - полноценная версия протокола, используемая в RabbitMQ из коробки начиная с версии 4.0.
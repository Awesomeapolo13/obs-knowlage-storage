
# Вариативные функции

**Ключи:**
- Обратные:
	- [Сведения о языке Go](GO);
	- [Функции Go](Go-functions);

**Хештеги:** #Programming/Go/Functions

## Спред оператор

Последний аргумент функции может быть вариативным. Функция может иметь максимум один вариативный аргумент и этот аргумент всегда слайс. Чтобы обозначить аргумент вариативным, нужно поставить три точки `...` перед его типом:

```go
package main

import ( "fmt" )

func main() { 
// кол-во аргументов может быть любым
	PrintNums(1, 2, 3)
}

func PrintNums(nums ...int) {
	for _, n := range nums {
		fmt.Println(n)
	}
}
```

Также тремя точками можно разбить слайс на элементы при передаче в вариативную функцию. Например, встроенный метод `append(slice []Type, elems ...Type) []Type`, который добавляет последний элемент в слайс, принимает вариативный аргумент `elems ...Type`. Чтобы добавить один слайс в конец другого, нужно разбить второй слайс на элементы путем добавления трех точек `...` после переменной:

```go
nums1 := []int{1,2,3,4,5}

nums2 := []int{6,7,8,9,10}

res := append(nums1, nums2...) // [1 2 3 4 5 6 7 8 9 10]
```

## Маппа функций

Чтобы не использовать свич кейс для выполнения разных функций можно создать из него маппу:

```go
var menu = map[string]func(string, int) (int int) {
	// Something happening
}
```

По сути это анонимная функция. В круглых скобках перечисляем типы аргументов, далее возвращаемые типы и пишем её тело. В целом всё как в обычных функциях.
Пример маппы для обработки выбора в меню (при передаче в строку будет вызвана одна из функций):

```go
var menuMap = map[string]func(*account.VaultWithDb) {  
    "1": createAccount,  // не указываем тут круглых скобок
    "2": findAccount,  
    "3": deleteAccount,  
}

func main() {
	vault := account.NewVault(files.NewJsonDB("data.json"))
    variant := "1"
    menuFunc := menuMap[variant] // тут возвращается имя функции
    if menuFunc == nil {  // если нет таких вариантов, то вернется nil
	    fmt.Printf("No such action %s. Please try again", variant)  
	}  
	menuFunc(vault) // вызываем выбранную функцию
}
```

## Функция как аргумент

Функция может быть передана как аргумент в другую функцию. В примере ниже метод структуры принимает функцию чеккер, которая работает с двумя аргументами, аккаунтом и строкой:

```go
func (vault *VaultWithDb) FindAccounts(str string, checker func(Account, string) bool) []Account {  
    var accounts []Account  
    for _, account := range vault.Accounts {  
       if checker(account, str) {  
          accounts = append(accounts, account)  
       }  
    }  
  
    return accounts  
}
```

Далее этот метод может быть вызван в любом месте, с передачей в него функции, удовлетворяющей паттерну:

```go
func findAccount(vault *account.VaultWithDb) {  
    // do something before
    accounts := vault.FindAccounts(url, checkUrl)  
    // do something after
}

func checkUrl(a account.Account, url string) bool {  
    return strings.Contains(a.Url, url)  
}
```

Такой способ позволяет использовать метод `FindAccounts` с разными паттернами для поиска в виде различных функций, что делает код переиспользуемым.

## Анонимные функции

Если функция используется лишь один раз в каком то конкретном случае, то нет нужды объявлять её. Вместо этого можно использовать анонимные функции. Пример кода выше, но с анонимной функцией:

```go
accounts := vault.FindAccounts(url, func(acc account.Account, str string) bool {  
    return strings.Contains(acc.Url, str)  
})
```

Разница лишь в том, что нужно передать имена аргументов и их типы.
Если же мы хотим переиспользовать код анонимной функции, то лучше объявить её отдельно и вызывать там где нужно.

## Замыкания

Функция так же может возвращать другую функцию. Это полезно для функций, которые являются фабриками других функций или структур.

```go
func factory() func(*account.VaultWithDb) {  
    return findAccountByUrl  
}
```

В качестве возвращаемого типа нужно указать функцию, с типами принимаемых аргументов. Таким же образом можно вернуть анонимную функцию.

```go
func factory(a string) func() {  
    return func() {  
  
    }  
}
```

Замыкание - Функция, которая захватывает и использует переменные из внешней области видимости. По сути это функция с дополнительным контекстом, вне своих границ. Например функция каунтер, ниже, будет изначально брать i как 0, во внешнем контексте, но в дальнейшем для увеличения i будет браться из внутреннего контекста анонимной функции.

```go
func menuCounter() func() {  
    i := 0  
    return func() {  
       i++  
       fmt.Println(i)  
    }  
}

func main() {
    counter := menuCounter()
    for {
        counter() // 0, 1, 2,
    }
}
```



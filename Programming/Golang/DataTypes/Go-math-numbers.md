
# Математика и числа в Go

**Ключи:**
- Обратные:
	- [Сведения о языке Go](GO);

**Хештеги:** #Programming/Go/DataTypes

## Числовые типы данных

В Go представлено много числовых типов данных: _uint_, _uint8_, _uint16_, _uint32_, _uint64_, _int_, _int8_, _int16_, _int32_, _int64_, _float32_, _float64_, _complex64_, _complex128_.  Одна из главных особенностей Go — это кроссплатформенность. Пишется один код, который компилируется и запускается на любой архитектуре процессора. В своем коде предпочтительнее использовать _int_ и _uint_, так как они являются архитектурно-независимыми: в момент компиляции принимают значение 32 или 64 битов под процессор.

Запоминать столько типов данных не нужно. В ежедневной работе чаще всего встречаются:

- _int_ - основной кросплатформенный тип целых чисел, может быть отрицательным;
- _int64_ - нужен для больших чисел из внешних систем. Например, ID в СУБД имеет тип _bigint_. Чтобы правильно распарсить такой ID, используется _int64_;
- _float64_ - число с плавающей точкой. Чаще всего используются для математических операций. Например, функция `math.Max`, определяющая наибольшее число, принимает аргументы в виде _float64_.

## Математические операции

В Go имеется стандартный набор арифметических операций:

```go
x := 10 y := 5

// сложение
x + y // 15

// вычитание
x - y // 5

// деление 
x / y // 2

// умножение
x * y // 50
```

Любые операции осуществляются только надо числами одинакового типа:

```go
x := 5.05
y := 10
x + y // invalid operation: x + y (mismatched types float64 and int)
```

Чтобы осуществить сложение разных числовых типов, нужно конвертировать значения к одному типу:

```go
x := 5.05
y := 10

x + float64(y) // 15.05
```

## Конвертация числовых типов

Числовые типы конвертируются без проблем между собой, однако есть нюансы, о которых стоит помнить:

```go
// нельзя конвертировать float64 к целому числу, если после точки не только нули
x := int64(5.05) // ошибка компиляции: constant 5.05 truncated to integer

x := int64(5.00) // OK

// uint не может быть отрицательным
x := uint(-5) // constant -5 overflows uint
```

Приведенные выше примеры вызовут ошибки компиляции, поэтому не удастся «выстрелить себе в ногу». Однако существуют способы обмануть компилятор, и тогда можно получить неявное поведение в коде

# Generic

**Ключи:**
- Обратные:
	- [Сведения о языке Go](GO);

**Хештеги:** #Programming/Go/DataTypes

## Общие сведения

Цель дженериков упростить переиспользование кода, когда нам нужны те же самые операции над похожими типами (например суммирование чисел int, int16, int32, float и прочих). Дженерик - некий обобщенный тип, который позволяет использовать одну и ту же функцию с разными типами.
Введены в go в версии 1.18.

```go
func sum[T int | float32 | float64 | string](a, b T) T { // В квадратных скобках описание дженерика (ограничения типа)
	return a + b
}
```

По сути в ограничения мы передаем некий юнион тип `int | float32 | float64 | string`.
Можно так же указать несколько дженериков через запятую:


```go
func sum[T int | float32 | float64 | string, V float64](a, b T) T { // В квадратных скобках описание дженерика (ограничения типа)
	return a + b
}
```

## Generic struct

Дженерики используются со структурами, например

```go
type List[T any] struct {  
    elements []T  
}
```

## Ограничения

Стоит учитывать, что если вставить в дженерик тип не поддерживающий операцию функции, например слайс при сложении, то мы получим ошибку. То есть типы в юнионе ограничены операциями, которые мы хотим над ними проводить в функции.

Так же нельзя использовать никакие конструкцию по уточнению типа с дженериком:

```go
func sum[T int | float32 | float64 | string](a, b T) T {
	val, ok := a.(int) // Для тайп свич все то же самое, сработает только по any типу
	return a + b
}
```

Но при использовании свич тайп, можно использовать явное преобразование к any типу.

```go
func sum[T int | float32 | float64 | string](a, b T) T {
	switch t := any(a).(type) {
	case string:
	case int:
	}
	return a + b
}
```

Так же в примере выше, мы не можем просто так вернуть строку или число, несмотря на то что они подпадают пол ограничения. Нужно либо убрать строку из ограничений, тогда сможем вернуть число. Либо возвращать результат операции между типами, т.к. это результат между типами T.

```go
func sum[T int | float32 | float64 | string](a, b T) T {
	return "sting" // Ошибка!
}

func sum[T int | float32 | float64 | string](a, b T) T {
	return 44 // И так ошибка!
}

func sum[T int | float32 | float64 | string](a, b T) T {
	return a + b // А так отлично!
}
```

Нельзя внутри юнионов использовать интерфейсы. Точнее можно указать  они интрефейс, но нельзя комбинировать его с другими типами независимо от того какие операции происходят в теле функции. Но можно использовать несколько структур.

```go
func sum[T int | float32 | float64 | string | error](a, b T) T { // Ошибка!
	// Что-то происходит
}

func sum[T voult.Account | account.AccountList](a, b T) T { // Ошибка!
	// Что-то происходит
}
```

Дженерики не работают в методах структур. Но можем использовать типы дженериков, находящиеся внутри структур.

```go
type List[T any] struct {  
    elements []T  
}

func (l *List[T]) addElement() {
	// Тут все верно
}

func (l *List[T]) addElement[V any](a V) {
	// Ошибка! Никаких доп дженериков в методы!
}
```


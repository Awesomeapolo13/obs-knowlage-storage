# Слайсы

**Ключи:**
- Обратные:
	- [Сведения о языке Go](GO);
	- [Коллекции](Go-collection-types);
- Прямые:
	- [Массивы](Go-array-type);
	- [Копирование слайсов](Go-slice-copy);
	- [Сортировка слайсов](Go-slice-sort);

**Хештеги:** #Programming/Go/DataTypes/Collection/Slice

## Основное

На практике не часто сталкиваешься с массивами из-за ограниченной длины при строгой типизации. Вместо этого повсеместно используются слайсы. Слайс — это массив _неопределенной_ длины (или динамический массив):

```go
var nums = []int{1,2,3}

nums := []int{1,2,3}
```

Чтение и запись осуществляется точно так же как в массивах:

```go
nums := []int{1,2,3}

nums[2] // 3

nums[0] = 10 // [10, 2, 3]

nums[:2] // [10, 2]
```

Ещё пример компирования данных из массива в слайс:

```go
transactions := [5]int{5, 10, -7, 10, 30}
partial := transactions[1:4] // [10, -7, 10] последний индекс не включается
partial = transactions[:4] // [5, 10, -7, 10] первый индекс берем с начала
partial = transactions[1:] // [5, 10, -7, 10, 30] с индекса 1 до конца
partial = transactions[:] // весь массив
```

При этом если использовать копирование по индексу слева, то capacity будет уменьшен, а если справа то нет. Более того, сдвигаясь по capacity можно вернуть старые значения:

```go
transactions := [6]int{5, 10, -7, 10, 30, 50}  
transactionsPartial := transactions[1:5] // Копируем 1 до 5 элементы
transactionsNewPartial := transactionsPartial[:1] // Копируем только первый элемент
transactionsNewPartial[0] = 1

fmt.Println(transactions)  // [5 1 -7 10 30 50]
fmt.Println(transactionsNewPartial)  // [1]
  
transactionsNewPartial = transactionsNewPartial[0:4]  // снова копируем, но уже с 0 до 4 элемента
  
//fmt.Println(transactionsPartial)  
fmt.Println(transactionsNewPartial)  // [1 -7 10 30] восстановили утраченные элементы
fmt.Println(len(transactionsPartial), cap(transactionsPartial))  
fmt.Println(len(transactionsNewPartial), cap(transactionsNewPartial))
```

Таким образом, **слайсы лишь ссылки на определенное окно нашего массива**.

В слайсы можно добавлять элементы с помощью встроенной функции `func append(slice []Type, elems ...Type) []Type`, которая возвращает новый слайс с добавленным элементом:

```go
words := []string{"hello"}

words = append(words, "world") // ["hello", "world"]
```

Если на один и тот же исходный слайс у нас ссылается несколько переменных, то при добавлении в исходный слайс нового элемента, изменения будут отражаться только в слайсе, которому будет присвоен append.

```go
transactions := []int{1, 2, 3}  
temp := transactions  
transactions = append(transactions, 100)  
fmt.Println(transactions)  // [1 2 3 100]
fmt.Println(temp) // [1 2 3], т.к. temp ссылается на данные до добавления
```

Так как слайс имеет нефиксированную длину, "под капотом" лежит более сложная структура, чем у массива. Помимо самих значений слайс хранит 2 дополнительных свойства: длину массива _len_ (длина) и _cap_ (вместимость). Благодаря этому возможно инициализировать слайс нужной длины с помощью встроенной функции `func make(t Type, len, cap IntegerType) Type`. Понимание, где лучше использовать какой способ инициализации, приходит с опытом, но для старта рекомендуется использовать `make` везде, где можно:

```go
// len = 5. Массив сразу будет заполнен 5-ю нулевыми значениями
nums := make([]int, 5, 5) // [0, 0, 0, 0, 0]

// len = 0, но cap = 5. Массив будет пустым, однако заполнение слайса через append будет эффективным, потому что в памяти уже выделен массив нужной длины
nums := make([]int, 0, 5) // []
```

Передача слайса как аргумента функции происходит хитро. Длина и вместимость передаются *по значению*, но массив значений передается *по ссылке*. Вследствие этого получается неявное поведение: **добавленные** элементы *не сохранятся в исходный слайс*, но **изменение** существующих *останется*:

```go
package main

import ( "fmt" )

func main() {
	nums := []int{1, 2, 3, 4, 5}
	modifySlice(nums)
	fmt.Println(nums) // [1 2 10 4 5]
}

func modifySlice(nums []int) {
	nums[2] = 10 // элемент будет и в исходном слайсе
	nums = append(nums, 6) // элемент не добавится в исходный слайс
}
```

Так же слайсы можно определить как ссылки на сегменты массивов. Они позволяют работать с частью массива без его копирования, экономя тем самым память.

## Работа capacity

Работа capacity в слайсах можно посмотреть в исходниках GO. Нам нужен репозиторий golang/go, файл go/src/runtime/slice.go. Метод - `nextslicecap(newLen, oldCap int)`.

Метод принимает новую и старую ёмкость массива. Если новая ёмкость превышает старую в два раза, то мы принимаем новое значение ёмкости.

Так же существует верхняя граница ёмкости в 256 элементов. Если старая ёмкость меньше 256, то мы просто удваиваем существующую ёмкость. В случае же превышения 256, новая ёмкость высчитывается как 1.25 от старой.







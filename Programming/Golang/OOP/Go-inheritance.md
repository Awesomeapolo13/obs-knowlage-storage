
# Наследование в GO

**Ключи:**
- Обратные:
	- [Сведения о языке Go](GO);

**Хештеги:** #Programming/Go/OOP

## Основы

В классическом виде (с использованием ключевого слова extends) наследование в GO отсутствует. Поэтому оно реализуется иными средствами:

Что дает наследование:

1. Повторное использование кода: класс-наследник получает всё содержимое класса-предка и добавляет своё.  
2. Динамический полиморфизм: переменная, у которой типом данных является некий базовый класс, может ссылаться как на объекты этого базового класса, так и на объекты его класса-наследника.  
3. Динамическая диспетчеризация: Метод с одним и тем же названием может иметь разную реализацию в классе-предке и классе-наследнике.

GO предлагает для решения проблемы повторного кода композицию и встраивание. Что же касается полиморфизма и динамической диспетчеризации - используются интерфейсы.

## Композиция

Если нам необходимо использовать внутри одной структуры другую, её расширяющую/дополняющую, то можно использовать композицию. Например, сделать Пожарнуб машину (FireEngine) членом машины (Car).

```go
type Car struct {
	// содержание структуры машины
}

type FireEngine struct {
	basis Car
	// Дополнение базовой машины функционалом пожарной
}
```

## Встраивание

Встраивание позволяет решить проблему дублирования кода. Ниже метод `Drive` будет передан дочерней структуре `FireEngine`, если мы не буем исползовать ключвое слово `basis`:

```go
type Car struct {
	// … содержимое
}
// Объявляем у Car метод
func (c *Car) Drive() { … }

type FireEngine struct {
	Car
	// … дополнение
}
```


## Интерфейсы

Интерфейсы определяют, что делает тип, а не кем он является.
Методы должны отражать поведение типа, поэтому интерфейсы объявляются с набором методов, которые тип должен обязательно иметь (`-able`).

Теперь допустим, что у нас есть много типов машин и каждая из них едет по своему. Выделим этот метод в интерфейс.

```go
type IDriveable interface {
	Drive()
}

type Car struct {
	// ...
}

type PoliceCar struct {
	// ...
}

func (c Car) Drive() {
	fmt.Println("Просто еду по дороге")
}

func (pc PoliceCar) Drive() {
	fmt.Println("Еду по дороге с мигалкой. Виу-виу!")
}

func main() {
	cars := []IDriveable{&Car{}, &PoliceCar{}}
	for _, vehicle := range cars {
		vehicle.Drive()
		// => Просто еду по дороге
		// => Еду по дороге с мигалкой. Виу-виу!
	}
}
```

Именование интерфейсов в виде "глагол + able" стандартно для большинства языков программирования. Однако в Go интерфейсы именуются немного по-другому. В данном случае интерфейс должен называться Driver.  
Подробнее про нейминг можно почитать в официальной документации Golang.

Так никакого явного указание реализации не требуется.  
Любой тип, который предоставляет методы, которые указаны в интерфейсе, можно считать реализующим интерфейс.
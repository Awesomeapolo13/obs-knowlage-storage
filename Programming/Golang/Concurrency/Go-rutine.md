
# Горутины

**Ключи:**
- Обратные:
	- [Сведения о языке Go](GO);
	- [Конкурентность в Go](Go-concurrency).

**Хештеги:** #Programming/Go/Concurrency

## Общие сведения

**Горутины** — это легковесные потоки, которые реализуют конкурентное программирование в Go. Их называют _легковесными потоками_, потому что они управляются рантаймом языка, а не операционной системой. Стоимость переключения контекста и расход памяти намного ниже, чем у потоков ОС. Следовательно, для Go — не проблема поддерживать одновременно десятки тысяч горутин.

 Для запуска функции в горутине достаточно написать слово `go` перед вызовом функции:

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// выведет сообщение в горутине
	go fmt.Println("Hello concurrent world")
	
	// если не подождать, то программа закончится, не успев, вывести сообщение 
	time.Sleep(100 * time.Millisecond)
}
```

При написании конкурентного кода возникают новые моменты, которые нужно учитывать: состояние гонки, блокировки, коммуникация между горутинами. Пример программы, которая работает не так, как ожидается:

 ```go
package main

import (
	"fmt"
	"time"
)

func main() {
	for i := 0; i < 5; i++ {
		go func() {
			fmt.Println(i)
		}()
	}
	
	time.Sleep(100 * time.Millisecond)
} 
```

Сперва може показаться, что должны вывестись числа от 0 до 4, но на самом деле вывод будет следующим:

```shell
5
5
5
5
5
```

Все потому что _i_ передается в общем скоупе, следовательно, когда горутины будут выполняться, цикл уже закончится и _i_ будет равно _5_. В данном случае нужно передать копию _i_:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    for i := 0; i < 5; i++ {
        go func(i int) {
            fmt.Println(i)
        }(i)
    }

    time.Sleep(100 * time.Millisecond)
}
```

Вывод:

```shell
0
4
3
1
2
```

Также можно заметить, что числа вывелись не в порядке вызова. Горутины выполняются независимо и не гарантируют порядка. При необходимости последовательность в выполнении придется реализовывать самостоятельно.


# Модульный монолит (Monolith first)

Подход к написанию приложения, когда сперва оно строится как монолит, но явно делится на различные модули с перспективой их вынесения в отдельные сервисы. 

Такой подход удобен в начале разработки, чтобы не усложнять проект разделением на микросервисы сразу.

![[Pasted image 20221022150435.png]]

Сперва надо определить контексты нашего приложения. Например, контекст пользователя, контекст email рассылки, контекст авторизации. 

Каждый контекст представляет собой отдельный модуль, организованный по принципу многослойной архитектуры.

Каждый интерфейс предоставляет наружу интерфейс. А другие модули могут иметь  адаптеры (anticorruption layer - предохранительный слой) для взаимодействия с другими модулями, не нарушая закон деметры и не усиливая связанность между модулями.

Множество модулей могут иметь общее ядро, которое представляет собой некую общую директорию, в которые могут быть вынесены общие интерфейсы, классы, зависимости фреймворка конфигурации и пр.

## Реализация

1) Создаем несколько директорий для каждого модуля, например для сущности пользователя Users, а корневую назовем Shared (в нее поместим Kernel.php - ядро всего проекта).
	В каждом модуле создаем следующие директории, отвечающие за соответвующие слои:
	* Domain - для слоя сущности;
	* Application - для слоя приложения;
	* Infrastructure - для инфраструкторного слоя.

	![[Pasted image 20221022163856.png]]

2) Далее работаем в директории Users Domain.
В доменном слое создадим необходимые для работы сущности, интерфейсы репозиториев, фабрики и др

![[Pasted image 20221022164303.png]]

Т.о. на доменном слое находятся интерфейсы.

3) Произведем реализацию доменных интерфейсов на инфраструктурном слое

![[Pasted image 20221022164810.png]]

4) Создадим для пример некий ModuleX по примеру из п.1
5) Теперь на примере ModuleX и Users покажем как модули взаимодействуют друг с другом. ModuleX - поставщик
	* Реализуем взаимодействие ModuleX - поставщик, Users - клиент;
	-  ModuleX предоставляет интерфейс класса API в диретории Infrastructure;
		![[Pasted image 20221022165612.png]]
		
		- Создаем в модуле Users на инфраструктурном слое адаптер для дступа к классу API - ModuleXAdapter;
		- В классе адаптера будет созависимость с модулем X (его надо проинициализировать в конструкторе);
		- В классе адаптера можно использовать любые зависимости из внешних модулей, вне адаптеров такое делать нельзя;
		- Создадим метод для конвертации данных из внещнего модуля во внутреннее представление;
		- Маппим данные из внешних сущностей во внутренние, преобразуем их и возвращаем.



## Работа с БД

1) Каждый модуль монолита должен содержать отдельный набор сущностей для работы с БД
2) Каждая таблица для модуля будет содержать префикс с именем модуля в нижнем регистре. То есть таблица для сущности User из модуля Users будет называться users_user

**Ключи:**
- [Многослойная архитектура](Onion-architecture)


**Хештеги:** #Programming/Arch

# Event loop


**Event Loop** - цикл с набором фаз, который забирает из очереди некоторые события, отправляет их на выполнение, если они тяжелые то через Worker Threads, затем получает результат и отправляет ответ.

!! При заполнении коллстека eventloop ждет пока он очистится.

Сначала происходит инициализация. Отрабатывают require и фиксации callback.
Далее последовательно выполняются шесть фаз.

![[Pasted image 20230202221907.png]]

После их выполнения мы попадаем в проверку окончания работы приложения (нет таймеров, ожидания http запросов и др.). Если проверка выполняется, то мы выходим из Event loop, если нет то отпрвляемся на следующую итерацию.

## Фазы

1) Таймеры - callback от запланированных таймеров.
	Смотрит есть ли какие либо таймеры, время которых вышло. Если есть то вызываются callback этих таймеров.

2) Pending callbacks - callback от системных операций.
	Если есть такие колбеки, они вызовутся в эту фазу.

3) idle, prepare - внутреннее использование. На эту фазу нам повлиять никак нельзя.

4) poll - расчет времени и обработка событий ввода / вывода (I/O).
	Читаем из файла, записываем в файл, когда приходит http запрос. Это фаза, в которой чаще всего приходят события от пользователей или внтури системы. Расчитывает время и число запросов, которое нам необходимо обработать. Затем переходит к следующей фазе и возвращается на следующем цикле к обработке запросов.

5) Check - происходит проверка и обработка setImmediate. Вызов некоторой функции, которая должна вызваться именно в эту фазу. Тут выполняется тяжелый синхронный код (перебор крупного массива данных).

6) Close callback - вызов события 'close', нгапример сокеты. Просто callbacks, вызываемые некоторыми событиями.

7) Кроме выше перечисленных фаз, между самими фазами происходят две вещи.
	- process.nextTick() - специально запланированное на nextTick событие, вызываемое в ручную;
	- other microtaskQueue - тут висят все Promises.

## Фазы наглядно

```js
const fs = require('fs');  
// Выполнится первым  
console.log('Init');  
// Выполнится 7-ым, поскольку уйдет на проверку event loop пока не пройдет таймер.  
setTimeout(() => {  
    console.log(performance.now(), 'Timer 0');  
}, 100);  
// Выполнится 6-м, т.к. данная функция относится к фазе check event loop (но если включены es modules, то не факт)  
setImmediate(() => {  
    console.log('Immediate');  
});  
// Текущий файл, выполнится последним (8-мым), потому что фаза poll происходит после таймера.  
fs.readFile(__filename, () => {  
    console.log('File loaded!');  
});  
// Ресурсоемкий адский цикл - выполнится 5-м, потому что ресурсоемкий колбек.  
setTimeout(() => {  
    for (let i = 0; i < 10000000000; i++) {  
  
    }    console.log('Great cycle ended');  
}, 0);  
  
// Промис - выполнится 4-м, потому как промесы разрешаются между фазами event loop.  
// Но сначала обработается очередь tick.  
Promise.resolve().then(() => {  
    console.log('Promise');  
});  
// Добавляет колбек в очередь next tick (откладывает выполнение до следующей фазы)  
// Выполнится третьим, потому как выполняется между фазами (в данном случае м-ду фазами таймеров и pending)  
process.nextTick(() => {  
    console.log('Tick');  
})  
  
// Выполнится вторым  
console.log('Final');
```

**Ключи:**
- [Node.js](node-js);
- [Timers](node-timer.md);
- [Callstack](node-callstack)
- [Worket threads](node-worker-threads.md);

**Хештеги:** #Programming/JS/NodeJs/EventLoop
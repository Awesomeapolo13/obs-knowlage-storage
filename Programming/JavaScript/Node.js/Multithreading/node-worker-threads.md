
# Worker threads

## Общее

Фактически они запускаются, когда необходимо выполнить какую то тяжелую задачу.
Упрощенная схема выглядит так:

![[Pasted image 20230205183136.png]]

То есть, тяжелая задача уходит в WT, обрабатывается и затем нам возвращается некоторый callback. На самом же дел не все трудоемки задачи передаются в worker treads.

## Как работает

Тут посмотрим ка Main tread передает задачи на обработку в Worker tread.

![[Pasted image 20230205183650.png]]

1) JS в главном процессе (Main Tread) вызывает некоторую функцию, требующую длительной обработки.
2) Функция js передается в C++ через внутренние биндинги.
3) С++ распаковывает JS объекты, определяет что это за задача и отправляет ее на выполнение.
4) Далее происходит обработка запроса и задача отдается в Worker Thread.
5) После этого C++ отправляет в JS подтверждение выполнения задачи и код JS продолжает работать.
6) Сам же WT, после выполнения работы, передает результат её выполнения в C++
7) Далее C++ вызывает JS код, который был указан в callback.

(Это работает так, потому что так устроет Libuv.)

!! На самом деле большинство задач будут выполняться без использования WT.

## Вызов асинхронности

Существует два способа взова асинхронных объектов - WT и Системные асинхронные вызовы на уровне ядра.

1) Worker threads - по умолчанию их 4 (идеально для 4-хядерного проца), можно поднять до 1024 (только если ядра 4, то задачи в них будут выполняться последовательно в каждом):
	- все файловые операции (модуль fs);
	- dns.lookup;
	- Pipes (некоторые задачи);
	- CPU intense tasks (ЦПУ интенсивные задачи, например, шифрования).
2) Системные асинхронные вызовы на уровне ядра
	- TCP / UDP - сервер и клиент (например, fetch);
	- Pipes;
	- DNS resolve;
	- Child process.

Например имеем такой код:

```js
const crypto = require('crypto');  
const start = performance.now();  
  
for (let i = 0; i < 55; i++) {  
    crypto.pbkdf2('test', 'salt', 100000, 64, 'sha512', () => {  
        console.log(performance.now() - start);  
    })  
}
```

Вывод ниже показывает что обработка шифрования пароля происходит по 4 пакета единовремнно.

```shell
72.58877199981362
78.6651539998129
79.00967099983245
79.14606299996376
----
139.84690300002694
143.08057500002906
145.53643900016323
146.8919159998186
-----
207.23535399977118
210.95600799983367
213.0616830000654
216.22294199978933
```

Если похожим способом отправлять http запросы, то мы получим результат не зависящий от ядер. Распределение будет равномернее. Это связано с тем, что процесс запросов выполняется на ядре.

**Ключи:**
- [Node.js](node-js);
- [Event loop](event-loop.md);
- [Управление worket threads](node-work-threads-manage.md);

**Хештеги:** 
- #Programming/JS/NodeJs/EventLoop;
- #Programming/JS/NodeJs/Multithreading;
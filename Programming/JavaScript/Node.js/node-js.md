
# Node.js

## Устройство

### Stack / Heap

Существует понятие стека и кучи.
Куча (Heap) - хранение в памяти нащих переменных.
Стек (Stack) - стек вызовов функций (вызов функций -> объявление переменной -> консоль.лог -> сет таймаут и т.д.). На сет таймаут он создаст дополнительный поток, чтобы не задерживать ответ.

![[Pasted image 20230131215144.png]]

**V8** - движок, обрабатывающий JS (по сути виртуальная машина для его обработки).
**Libuv** - реализует концепции Event Loop, thread pool, async I/O (асинхронный ввод и вывод).
**NodeJS bindings** - библиотеки, позволяющие вызовы JS преобразовывать к вызовам C/C++.

### Обработка запроса на Node.js

![[Pasted image 20230131215743.png]]

1) Приходит запрос.
2) Запрос обрабатывается.
3) Движок начинает обработку кода.
4) Node bindings преобразует код к некоторым event (событиям).
5) Событие отправляется в очередь.
6) Event Loop забирает событие из очереди и отправляет в Callstack.
7) Callstack выполняет JS код, если он встречает что-то, требующее большой производительности (либо API для выдержки времени) - отправляет в Working Threads (network / filesystem / ... - воркеры выполняющие операции, требующие много ресурсов).
8) Working Threads, после выполнения трудоемких задач, отправляет результаты в Event Queue.
9) Event Loop получает результаты из очереди и вызывает callback через callstack.
10) По завершению работы Event Loop отпрвляет  ответ.

Event Loop - цикл с набором фаз, который забирает из очереди некоторые события, отправляет их на выполнение, если они тяжелые то через Worker Threads, затем получает результат и отправляет ответ.

!! При заполнении коллстека eventloop ждет пока он очистится.

## Почему используют

- простой переход от front к back (легче переносить знания);
- возможность балансировать нагрузку в командах (можно переносить разработчиков с front задач на back);
- единые интерфейсы и модули для front и back (можно сделать библиотеку сразу и для front и для back);
- множество пакетов для работы с чем угодно.

## Для чего используют

1) Backend for frontend - можно сделать прослойку для фронта, которая будет проверять данные перед отправкой на реальный бек.
2) REST API.
3) GraphQL API.
4) Backend - можно писать хороший типизированный бекенд на ноде.
5) Microservices - хорошо подходит для микросервисной архитектуры.
6) Web-scraping - процесс сбора данных с помощью программы (еще называют парсингом веб страниц).
7) Document generation - генерация документов (например из html в pdf).
8) Test automation - автоматизация тестов.
9) Server-side rendering - если нужно зарендерить фронтенд на беке и отправить его для дальнейшего редактирования на фронт.

## Для чего не подходит

1) Низкоуровневое программирование.
2) Сложные многопоточные приложения - в ней легко создаются отдельные потоки, но дальнейшее их слияние проблематично.
3) Программирование микроконтроллеров.

## Проблемы

1) Нет строгих типов и статических анализаторов - решаются использованием TypeScript
2) Нет стандарта архитектуры - ранее использовали express.js, а уже над ним делали свой фреймворк надстройкой. Сейчас есть крупные игроки вроде Next.js, которые предоставляют готовую архитектуру.
3) Однопоточность - основное поток один, но она не однопоточная, после получения запроса потоки распределяются.

**Ключи:**
- [Программирование](PROGRAMMING);
- [JS](javascript);
- [GraphQL](graphql.md);
- [Node version manager](nvm);
- [Различия сред выполнения JS](js-env-compare);
- [REPL режим](repl-mode);
- [Глобальные переменные](node-global-variables);
- [Историческая справка](node-history);
- [Event loop](event-loop.md);
- [Оценка производительности](node-perfomance-estimating);
- [Модули JS](node-js);
- [Exec and spawn commands](exec-and-spawn-command);
- [Fork](node-fork);
- [Движок V8](v8-driver);

**Хештеги:** #Programming/JS/NodeJs
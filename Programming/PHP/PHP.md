
# Язык программирования PHP

**Связи:**
- Обратные
	- [Программирование](PROGRAMMING);
- Прямые:
	- [Полезные команды](Php-commands);
	- [Статические переменные](Static-variables);
	- [Статические анализаторы кода](static-code-analizers);
	- [Компиляция](PHP-compilation);

**Хештеги:** #Programming/PHP

## Определение и особенности

**PHP** - синхронный, интерпертируемый, серверный язык программирования, используемый преимущественно для веб-разработки.

**PHP (Hypertext Preprocessor)** — это широко используемый язык программирования с открытым исходным кодом, особенно подходящий для веб-разработки и встраиваемый в HTML. Вот некоторые ключевые особенности, сильные и слабые стороны PHP:

- **Серверный Скриптовый Язык:** PHP в основном используется для серверной разработки, что означает, что скрипты PHP выполняются на сервере, а результаты отправляются клиенту.
- **Легко Встраиваемый в HTML:** PHP может легко встраиваться в HTML-код, что делает его удобным для создания динамических веб-страниц.
- **Большая Стандартная Библиотека:** PHP имеет обширную стандартную библиотеку, включающую широкий спектр встроенных функций для работы с файлами, базами данных, сессиями и многим другим.
- **Поддержка Баз Данных:** PHP поддерживает широкий спектр систем управления базами данных.
- **Кроссплатформенность:** PHP может работать на различных операционных системах, таких как Linux, Windows и macOS.

### История

Создан 08.06.1995 Расмусом Лефордом. Изначально назывался PHP Tools (Personal Home Page Tools). Создавался как интерпретатор шаблонов (шаблонизатор) для ускорения веб-разработки. В 1998 году полностью переписан на C.

### Свойства

1) Написан на C
2) Интерпретируемый (Компилируемый), т.к. все преобразуется в байт код.
3) Динамически типизируемый

### Достоинства

- требует мало времени на изучение;
- много возможностей при хорошем владении;
- кроссплатформенность (запускается на любой ОС);
- поддержка веб-серверов;
- бесплатное распространение;
- достаточная производительность;
- большое количество учебных материалов.
- непрерывное развитие.

### Недостатки

- узкопрофильность (используется только в веб);
- безопасность;
- противоречия в коде (много всего из разных языков, в том числе плохого);

## Как работает

1) Web-сервер получает запрос из браузера клиента (или от приложения).
2) Web-сервер формирует запрос к PHP-интерпретатору.
3) PHP-интерпретатор обрабатывает его, получает небходимые данные и возвращает их в каком либо формате (json, xml, html) web-серверу.
4) Web-сервер отправляет данные клиенту.

## Модель памяти

В режиме web-server php может обрабатывать несколько запросов. Для каждого из них запускается отдельный процесс (т.е. отдельная копия кода php). Каждому процессу выделяется оперативная память.

При старте PHP, независимо от того какого она размера, выделяется 2Mb. Принеобходимости процесс может запросить дополнительную память. Новая память выделяется чанками, обычно, по 2Mb. Процесс не сможет получить дополнительную память либо, если кончилась оперативная память, либо если текущая память превышет указанную в `php.ini` файле в параметре `max_memory`.

Память состоит из двух частей. Первая называется стек -  тут лежат маленькие переменные, необходимые для работы конкретных функций. Вторая, более крупная часть, куча - здесь хранятся крупные переменные, массивы, объекты и пр.

В языках со статической типизацией (строгой) переменные создаются через объявление типа и, затем, присваивание значения. Изменить тип в дальнейшем невозможно. Благодаря этому, переменная будет всегда занимать строго фиксированное количество байт.

`zval` - способ представления переменных внутри php. Есть переменная, у неё есть тип и значение, которые затем можно поменять в любой момент. При этом слева и справа в оперативной памяти лежат переменные, которые надо как то раздвинуть. Это решается с помощью `zval`:
- выделяем 16 байт под сам `zval`;
- под значение выделяется 8 байт;
- небольшие знначения хранятся прямо внутри `zval`;
- если значение крупнее (строка, массив или др.), то хранится отдельно (в куче), а в `zval` лежит укаазатель на них.

Т.о. при изменении типа `zval` как был 16 байт, так и остался, в нем меняется тип переменной, и на куче выделяется память под новое значение (а в `zval` устанавливается указатель на новое значени в куче).

В случае с массивами каждый элемент - это `zval`. Все элементы лежат отдельно от массива в оперативной памяти в том порядке, в котором вы их задали в исходном коде.

По умолчанию массив в php создает массив из 8 элементов. При увеличении количества элементов, он расширяет его на 8 и так до бесконечности. При этом, в момент расширения массива, php хранит в памяти и старый массив, занимая им память, пока не переместит его элементы во второй. Массивы в php могут только расти (даже если вызвать `unset()` или очистить его совсем размер массива в памяти не изменится) до тех пор, пока не удалить их из памяти.

## Сборка мусора

Нельзя просто так удалить массив или объект, потому как он может использоваться в других местах (иметь ссылки в других местах).

Как работает сборка мусора:
- на куче лежат контейнеры (строки, массивы, объекты и пр.);
- ссылки на эти контейнеры (указатели) хранятся в самих переменных;
- для каждого контейнера заводится счетчик ссылок refcount и как только он станет равен 0 - контейнер будет удален;

Так же существует проблема `циклических ссылок`:
- у нас есть переменная `$a`;
- она ссылается на переменную `$b`;
- а переменная `$b` ссылается на `$a`;
- теперь, даже если удалить обе переменных, их refcount будет больше 0.

Сборщик мусора в php обходит контейнеры в памяти, находит циклические ссылки, которые больше не нужны и удаляет их. Но иногда его нужно запускать в ручную функцией gc_collect_cycles()).

## Повышение производительности

### Опкеш

Для ускорения работы php существует механизм, позволяющий закешировать опкоды после первой компиляции (чтобы не повторять её после каждого запроса, т.к. результат этой компиляции не меняется). Этот механизм называется OPcache.

Т.е. при первом запусте происходит компиляция. Затем полученные опкоды сохраняются в специальный кеш. При последующих запросах они берутся их этого кеша без компиляции.

### Предзагрузка (PHP 7.4+)

Мы можем получить закешированные опкоды и не повторять компиляцию, но необходимо все равно запустить скрипт, чтобы получить их и положить кеш.

Функционал предзагрузк (preloading) создает опкоды и записывает их в кеш ещё до первого запроса. Т.е. мы заранее прогреваем кеш.

Прирост производительности после первого захода получается +25%

### JIT (PHP 8.0+)

Итак мы можем кешировать опкоды до первого запроса, но нам всё равно нужно выполнять их в виртуальной среде (на ВМ PHP). На это выполнение тратится время, а именно на их интерпретацию в машинный код.

JIT (just in time) компилятор - это ещё один кеш, но уже для машинного кода. Т.о. для выполнения операций нам уже не нужна виртуальная машина.

Но прирость производительности небольшой (единицы процентов). Потому что сам по себе процессор в веб приложениях не нужен, т.к. много времени уходит на взаимодействие с другими службами (БД, другие API)

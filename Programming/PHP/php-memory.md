
# Модель памяти

**Связи:**
- Обратные
	- [PHP](PHP);
- Прямые:
	

**Хештеги:** #Programming/PHP 

## Модель 

В режиме web-server php может обрабатывать несколько запросов. Для каждого из них запускается отдельный процесс (т.е. отдельная копия кода php). Каждому процессу выделяется оперативная память.

При старте PHP, независимо от того какого она размера, выделяется 2Mb. При необходимости процесс может запросить дополнительную память. Новая память выделяется чанками, обычно, по 2Mb. Процесс не сможет получить дополнительную память, либо если кончилась оперативная память, либо если текущая память превышет указанную в `php.ini` файле в параметре `max_memory`.

Память состоит из двух частей. Первая называется стек -  тут лежат маленькие переменные, необходимые для работы конкретных функций. Вторая, более крупная часть, куча - здесь хранятся крупные переменные, массивы, объекты и пр.

В языках со статической типизацией (строгой) переменные создаются через объявление типа и, затем, присваивание значения. Изменить тип в дальнейшем невозможно. Благодаря этому, переменная будет всегда занимать строго фиксированное количество байт.

Для реализации хранения переменных в динамически типизированных ЯП используются иные способы. В php это `zval` (`zend value`).

## ZVAL (Zend Value)

`zval` - способ представления переменных внутри php. Есть переменная, у неё есть тип и значение, которые затем можно поменять в любой момент. При этом слева и справа в оперативной памяти лежат переменные, которые надо как то раздвинуть. Это решается с помощью `zval`:
- выделяем 16 байт под сам `zval`;
- под значение выделяется 8 байт;
- небольшие значения хранятся прямо внутри `zval`;
- если значение крупнее (строка, массив или др.), то хранится отдельно (в куче), а в `zval` лежит укаазатель на них.

Т.о. при изменении типа `zval` как был 16 байт, так и остался, в нем меняется тип переменной, и на куче выделяется память под новое значение (а в `zval` устанавливается указатель на новое значени в куче).

В случае с массивами каждый элемент - это `zval`. Все элементы лежат отдельно от массива в оперативной памяти в том порядке, в котором вы их задали в исходном коде.

По умолчанию массив в php создает массив из 8 элементов. При увеличении количества элементов, он расширяет его на 8 и так до бесконечности. При этом, в момент расширения массива, php хранит в памяти и старый массив, занимая им память, пока не переместит его элементы во второй. Массивы в php могут только расти (даже если вызвать `unset()` или очистить его совсем размер массива в памяти не изменится) до тех пор, пока не удалить их из памяти.

### Структура zval

В php версий 7+ структура zval была сильно изменена и теперь имеет следующий вид:

```c
typedef struct _zval_struct {
    zend_value        value;      // Само значение переменной
    union {
        struct {
            zend_uchar    type;   // Тип значения (строка, int, массив и т.д.)
            zend_uchar    type_flags;
            union {
                uint16_t  extra;  // Дополнительная информация, которая варьируется в зависимости от типа данных
            } u;
        } v;
        uint32_t type_info;       // Поле для хранения всей необходимой информации о типе
    } u1;
    union {
        uint32_t     next;        // Используется сборщиком мусора (GC)
        uint32_t     cache_slot;  // Слот кеша для ускорения операций
        uint32_t     lineno;      // Линия кода, откуда была вызвана переменная (в целях отладки)
        uint32_t     num_args;    // Количество аргументов (например, для функций)
    } u2;
} zval;
```

1. `zend_value value` - это ключевое поле, где хранится само значение переменной. Это может быть строка, число, массив, объект и т.д. Поле `zend_value` — это объединение (union), которое позволяет хранить различные типы данных, используя одно и то же место в памяти.

```c
typedef union _zend_value {
    zend_long         lval;        // long integer (целое число)
    double            dval;        // double (вещественное число)
    zend_refcounted  *counted;     // Ссылка на структуру с refcount
    zend_string      *str;         // Ссылка на строку
    zend_array       *arr;         // Ссылка на массив
    zend_object      *obj;         // Ссылка на объект
    zend_resource    *res;         // Ссылка на ресурс (например, файл)
    zend_reference   *ref;         // Ссылка на ссылку (используется для & ссылок)
    zend_ast_ref     *ast;         // Ссылка на синтаксическое дерево (AST)
} zend_value;

```

2. `u1` - тип значения и метаданные. В объединении `u1` хранится информация о типе данных переменной и несколько служебных данных, таких как флаги и дополнительная информация. Поле `type` — это байт, который хранит текущий тип переменной:

```c
zend_uchar type;  // Тип переменной
```

Типы, представленные в `zval`, могут быть следующими:

- `IS_NULL`: переменная является `NULL`.
- `IS_LONG`: целое число.
- `IS_DOUBLE`: вещественное число.
- `IS_STRING`: строка.
- `IS_ARRAY`: массив.
- `IS_OBJECT`: объект.
- `IS_REFERENCE`: ссылка (используется для переменных, переданных по ссылке).

Также есть поле `type_flags`, которое хранит флаги, используемые для различных оптимизаций и проверки дополнительных состояний переменной.

3. `u2` - дополнительные данные. Это второе объединение, содержащее данные для работы сборщика мусора, кеша и других систем:

- `next`: используется для сборки мусора (Garbage Collection, GC) для связывания элементов.
- `cache_slot`: может использоваться как место для кеширования, чтобы ускорить доступ к переменной.
- `lineno`: хранит строку кода, из которой была вызвана переменная (удобно для отладки).
- `num_args`: используется для хранения количества аргументов функции.

### Счетчик ссылок и управление памятью

PHP использует **счетчики ссылок** (reference counting) для управления памятью. Это означает, что PHP отслеживает, сколько переменных ссылаются на одно и то же значение. Если счетчик ссылок падает до нуля, память, занимаемая этим значением, освобождается.

Для объектов, массивов, строк и других "сложных" типов данных используется структура `zend_refcounted`, которая содержит счетчик ссылок и дополнительные метаданные. Поле `zend_value *counted` в `zval` ссылается на эту структуру.

```c
typedef struct _zend_refcounted_h {
    uint32_t         refcount;  // Счетчик ссылок
    union {
        struct {
            zend_uchar    type;  // Тип данных
            zend_uchar    flags; // Флаги
            uint16_t      gc_info; // Данные для сборщика мусора
        } v;
        uint32_t type_info;  // Вся информация о типе
    } u;
} zend_refcounted_h;
```

Когда несколько переменных ссылаются на одно и то же значение, вместо копирования данных увеличивается `refcount`. Если одна из переменных модифицируется, происходит операция **copy-on-write** — данные копируются, а счетчик ссылок уменьшается.

### Пример работы zval

Представь следующий код:

```php
$a = 42;       // zval хранит целое число 42
$b = $a;       // $b ссылается на то же значение, счетчик ссылок не увеличивается (для простых типов)
$a = "test";   // Теперь zval $a обновляется, чтобы хранить строку "test"`
```

Здесь происходит следующее:

1. Когда ты присваиваешь `$a = 42;`, создается `zval`, где в поле `value.lval` хранится число 42, а `type` установлен в `IS_LONG`.
2. При копировании `$b = $a;`, так как `zval` для `$a` содержит простое значение (integer), оно просто копируется в `$b`. Никакого увеличения счетчика ссылок не происходит, так как простые типы данных (int, double) не используют систему ссылок.
3. Когда ты меняешь `$a = "test";`, тип `zval` для переменной `$a` меняется на `IS_STRING`, создается новое значение, и в поле `value.str` сохраняется строка "test".
# Генераторы

**Связи:**
- Обратные
	- [PHP](PHP);

**Хештеги:** #Programming/PHP

# Определение

Генератор - конструкция языка php, которая предоставляет способ реализации простых итераторов без использования дополнительных ресурсов или сложностей, связанных с реализацией класса, использующего интерфейс Iterator.

По сути это однонаправленный, одноразовый итератор.

## Цель

Генератор позволяет вам писать код, использующий `foreach` для перебора набора данных без необходимости создания массива в памяти, что может привести к превышению лимита памяти, либо потребует довольно много времени для его создания. Вместо этого, вы можете написать функцию-генератор, которая, по сути, является обычной функцией, за исключением того, что вместо возврата единственного значения, генератор может возвращать (`yield`) столько раз, сколько необходимо для генерации значений, позволяющих перебрать исходный набор данных.

Реализуя итератор в php нужно понимать их недостатки:
- удобная абстракция надо данными, которые можно перебирать (есть методы, которые надо реализовать);
- они решают множество проблем;
- при всем этом их код многословен, запутан и его сложно читать.

При использовании генератора:
- более удобный способ разработки итератора;
- не нужно заботиться о реализации всех методов;
- просто вызываем `yield` в нужных местах.

Для чего использовать генератор:
- взаимодействие с API;
- загрузка больших объемов из БД;
- чтение и обработка огромных файлов (логи);
- обход каталогов и файлов на диске;
- создание тестовых кейсов в PHPUnit (Data Provider).

## Что делает `yield`

1) Запоминает внутреннее состаяние генератора (значение переменных и пр.);
2) Ставит на паузу выполенение генератора;
3) Возвращает промежуточное значение.

Генератор автоматически продолжит раюоту с этого мета при следующей итерации `foreach()`.

Таким образом мы имеем дело с некоторой шестеренкой, которая крутится не внутри  некой функции, а которую мы можем повернуть нужное нам количество раз.

![[Pasted image 20240512142326.png]]

## Особенности

1) Функция генератор возвращает **одноразовый** итератор;
2) Код итератора не запускается автоматически (этот одноразовый итератор надо далее использовать по коду самому);
3) Итератор генератора, в отличие от массива, можно перебрать лишь один раз (т.е. если нужно перебрать еще раз - снова вызываем функцию генератор).

## Цепочка генераторов (ленивые вычисления)

1) Можем создать цепочку генераторов;
2) Начальное звено цепочки - поставщик потока данных;
3) Поток данных может быть бесконечным;
4) Промежуточные звенья выполняют преобразования потока данных;
5) Последнее звено цепочки передаётся в `foreach()`.

Как работает такой код:

1) Код начинает работать только в момент вызова `foreach()`.
2) `foreach()` вытягивает данные из последнего звена.
3) Это действие распространяется от конца к началу цепочки.
4) Самым последним вызывается `yield` в начальном звене.

![[Pasted image 20240512143910.png]]

По аналогии с рисунком выше, первое зубчатое колесо (котрое в конце, т.е. последнее), приводит в движение все остальные по цепочке.

- это эквивалент ленивых вычислений в ФП;
- новые элементы появляются только в самый последний момент;
- такие цепочки можно использовать для реализации реактивности;

Такие цепочки удобны для:
- фильтрации (filter);
- преобразование (map);
- свёртку (reduce);
- многое другое.

Преимущества:
- вохможность обработки больших данных;
- низкое потребление памяти;
- такой код легко читать и писать;
- такой код легко развивать.

Обработка потоков данных в целом обычно реализуется в функциональной парадигме.

Недостатки цепочек генераторов:

- магия генераторов ломается, если преобразовать результат в массив;
- данные нужно обрабатывать на лету по мере их появления;
- каждый элемент в цепочке должен возвращать новый генератор.

## Пример

Простейший генератор выглядит как на коде ниже. 

```php
function oneToTenGenerator(): Generator {
	yield 1;
	yield 2;
	yield 3;
	yield 4;
	yield 5;
	yield 6;
	yield 7;
	yield 8;
	yield 9;
	yield 10;
}

$iterator = oneToTenGenerator();

foreach ($iterator as $key => $value) {
	echo "{$key}: {$value}" . PHP_EOL;
}
```

Функция последовательно отдает каждое значение в `yield`. Аналогично код выше можно переписать:

```php
function oneToTenGenerator(): Generator {
	foreach ($i = 1 $i <= 10; $i++) {
		echo "Возвращаем $i" . PHP_EOL;
		yield $i;
	}
}

$iterator = oneToTenGenerator();

foreach ($iterator as $key => $value) {
	echo "{$key}: {$value}" . PHP_EOL;
}
```
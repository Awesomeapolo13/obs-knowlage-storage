# Компиляция

**Связи:**
- Обратные
	- [PHP](PHP);
- Прямые:

**Хештеги:** #Programming/PHP

## Лексический анализ

В общем случае:
- у нас есть какой-то текст (код программы);
- разбираемся из чего она состоит (слова, знаки препинания и пр.);
- эти составляющие называются "лексемы".

В PHP:
1) Движок PHP ищет знакомые ему лексемы с помощью re2c (по сути анализ регуляркой).
2) Механизм разбиваем программу на эти лексемы.
3) Каждой лексеме подбирается подходящий токен (`T_FUNCTION`, `T_VARIABLE` и др.).
4) В итоге написанный код превращается в массив токенов (пример ниже, так же можно посмотреть лексемы кода, обернув его в `$code = <<<'CODE' CODE;` и вызвав функцию `\PHPToken::tokenize($code)` - результат вывести через `foreach`).

![[Pasted image 20240305145646.png]]

5) Так же php может разбирать и другие строки на человеческом языке:
	- JSON;
	- дата/время;
	- SQL (PDO);
	- URL и др.
6) По итогу лексического анализа получаем:
	- массив токенов;
	- php отметил знакомые ему слова;
	- теперь надо проверить корректно ли слова включаются в предложения.


## Синтаксический анализ

Синтаксический анализ группирует операции. Условно это:
- представляет массив токенов как очень длинное математическое выражение;
- для вычисления выражения "расставляет в нем скобочки";
- Фрома Бэкуса-Наура - способ описания грамматики языка (её аналоги часто встречаются в документации), она есть и для php, в ней желательно разобраться.

 В PHP:
1)  Для php есть своя грамматика языка.
2) Программа GNU Bison берёт эту грамматику и генерирует парсер (программу, которая генерируется на ПК в момент компиляции PHP).
3) Парсер применяет грамматику к массиву токенов.
4) В результате массив превращается в AST - абстрактное синтаксическое дерево (astexplorer.net - тут можно на любом ЯП написать код и посмотреть его AST), в котором:
	- корень - самое начало программы;
	- каждый узел - отдельная операция;
	- дочерние узлы - аргументы этой операции.

![[Pasted image 20240219135517.png]]

5) В итоге после синтаксического анализа имеем:
	- PHP разобрался, какие операции упоминаются в коде;
	- после чего сгруппировал их в нужном порядке;
	- теперь нам нужно сделать так, чтобы эти операции запустились на компьютере.

## Компиляция

В целом:
1) Проверяет семантику (смысл написанного, причем однозначный).
2) Превращает дерево с исходным кодом в опкоды (PHP запускается не на процессоре, а внутри специальной виртуальной машине PHP Zend Engine, которая умеет выполнять промежуточные инструкции - опкоды)
3) Виртуальная машина нужна, чтобы запускать код на любом устойстве, поддерживающем php, независимо от её архитектуры (абстрагировать процесс php от реального процесса).

В PHP:
1) PHP рекурсивно обходит AST в несколько подходов.
2) При этом происходит оптимизация дерева.
3) В итоге дерево превращается в набор опкодов.
4) При этом для каждой функции готовится массив опкодов плюс информация о переменных, которые в них нужно подставить.
5) Опкоды (https:/3v4l.org/ - тут можно посмотреть опкоды):
	- выполняют сравнительно простые операции;
	- порядок выполнения - строго по очереди;
	- для циклов, условных выражений и др, используются опкоды напоминающие GOTO.

## Запуск программы (Runtime)

Для запуска программы необходимо:
1) Комманды, которые будет выполнять программа.
2) Данные, которые она будет обрабатывать.
3) Память, где всё это будет размещаться.

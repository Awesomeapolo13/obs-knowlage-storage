
# Алгоритм быстрой сортировки #

**Хештеги**:
* #Programming/Algorithms/Sort;
* #Programming/Algorithms/Recursion 

## Зачем нужен ##

Для быстрой сортировки списка.
Алгоритм основан на свойстве отсортированного масива. 
Массив отсортирован тогда и только тогда, когда для любого его элемента все элементы, находящиеся слева, не больше этого элемента, в все, находящтеся справа - не меньше.

Временная сложность -  $O(n*log(n))$.
Может достигать квадратичного времени на плохо отсортированных массивах.

## Условия для использования ##
Нет

## Алгоритм ##

1) **Выбор опорного элемента** — можно брать первый, последний, средний элемент или случайный. Выбор влияет на производительность в худших случаях.
2) **Разбиение (partition)** — перестановка элементов массива так, чтобы:
    - Все элементы меньше опорного оказались слева от него
    - Все элементы больше опорного — справа
    - Опорный элемент встал на свое окончательное место
3) **Рекурсивная сортировка** — применение того же алгоритма к левой части (элементы меньше опорного) и правой части (элементы больше опорного)
4) **Базовый случай** — когда в части массива остается 0 или 1 элемент, она уже отсортирована

## Реализация ##

```go
package quickSort

// QuickSortIntSliceASC сортирует слайс целых чисел по возрастанию
func QuickSortIntSliceASC(arr []int, firstIdx, lastIdx int) []int {
    // Базовый случай: если в части массива 0 или 1 элемент, она уже отсортирована
    if firstIdx >= lastIdx {
        return arr
    }
    
    // Выполняем разбиение и получаем позицию опорного элемента
    pivotIdx := partition(arr, firstIdx, lastIdx)
    
    // Рекурсивно сортируем левую часть (элементы меньше опорного)
    QuickSortIntSliceASC(arr, firstIdx, pivotIdx-1)
    
    // Рекурсивно сортируем правую часть (элементы больше опорного)
    QuickSortIntSliceASC(arr, pivotIdx+1, lastIdx)
    
    return arr
}

// partition выполняет разбиение массива относительно опорного элемента
func partition(arr []int, firstIdx, lastIdx int) int {
    // Выбираем последний элемент как опорный
    pivot := arr[lastIdx]
    
    // Индекс для размещения элементов меньше опорного
    i := firstIdx - 1
    
    // Проходим по всем элементам кроме опорного
    for j := firstIdx; j < lastIdx; j++ {
        // Если текущий элемент меньше или равен опорному
        if arr[j] <= pivot {
            i++ // увеличиваем индекс для меньших элементов
            // Меняем местами элементы
            arr[i], arr[j] = arr[j], arr[i]
        }
    }
    
    // Помещаем опорный элемент на правильное место
    arr[i+1], arr[lastIdx] = arr[lastIdx], arr[i+1]
    
    // Возвращаем позицию опорного элемента
    return i + 1
}

// Альтернативная версия с более простым интерфейсом
func QuickSort(arr []int) []int {
    if len(arr) <= 1 {
        return arr
    }
    return QuickSortIntSliceASC(arr, 0, len(arr)-1)
}
```

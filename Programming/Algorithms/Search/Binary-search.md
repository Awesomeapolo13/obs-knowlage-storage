
# Алгоритм бинарного поиска #

## Зачем нужен ##

При поиске элемента массива простым перебором сложность $O(n)$.
При небольшом n такой алгоритм будет работать нормально. При значительном увеличении n, алгоритм начинает работать медленнее.

Для решения этой проблемы придумали алгорит бинарного поиска.

Временная сложность такого алгоритма - $O(log(n))$.

## Условия для использования ##
Нужна предварительная сортировка массива по искомому параметру.

## Алгоритм ##

1) Делим список попалам;
2) Сравниваем искомый элемент с центральным и проверяем в какой части списка искомая строка. Если количество элементов списка четное, то сравниваем с двумя элементами (до и после разделения списка);
3) Если искомый элемент явно выше или ниже сравниваемого (например, фамилия Матвеев явно ниже фамилии Кандауров), то часть списка не подходящую для сравнения убираем;
4) С оставшейся половиной списка делаем то же самое (делим попалам и убираем лишнее);
5) Если при сравнении элемент нашелся или можно сделать вывод о его явном отсутствии (например, после фамилии на Л сразу идет фамилия на С), то завершаем алгоритм.

## Реализация ##

Реализацяи на JS

```javascript
/**
 * Функция, реализующая влгоритм бинарного поиска
 * @param searchingArr
 * @param query
 * @param from
 * @param to
 * @param oldMiddleEl - средний параметр из предыдущего шага.
 * @returns {string, undefined}
 */
function binarySearch(
    searchingArr,
    query,
    from,
    to,
    oldMiddleEl = null
) {
    // проверка типов входных данных
    if (
        typeof(searchingArr) !== "object" ||
        typeof(query) !== "string" ||
        typeof(from) !== "number" ||
        typeof(to) !== "number"
    ) {
        throw new Error('Не верный формат аргументов в функции binarySearch!');
    }

    // Определяем средний элемент
    let middle = Math.round(((from + to) / 2) - 1);
    let middleEl = searchingArr[middle];
    // Если равен ворвращаем его
    if (query === middleEl) {
        return middleEl;
    }
    // Если средний элемент равен тому, что был на предыдущем шаге, то значит искомой строки нет
    if (middleEl === oldMiddleEl) {
        return undefined;
    }
    // Если больше или меньше то рекурсия с изменениемпараметра from
    if (query > middleEl) {
        return binarySearch(searchingArr, query, middle, to, middleEl);
    }

    if (query < middleEl) {
        return binarySearch(searchingArr, query, from, middle, middleEl);
    }
}
```

**Хештеги**:
* #Programming/Algorithms/Search;
* #Programming/Algorithms/Recursion 
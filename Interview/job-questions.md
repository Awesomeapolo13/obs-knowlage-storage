# Вопросы на интервью для повторения

**Ключи:**
- Обратные:
	- [Программирование](PROGRAMMING);

**Хештеги:**
- #Interview 

## Вопрос - ответ

1) **Чем Dependency Injection отличается от Dependency Inversion?**

Dependency Inversion:
- это принцип проектирования;
- относится к тому, как модули должны зависеть от низкоуровневых (оба должны зависеть от абстракций);
- цель - уменьшить связность между модулями.

Dependency Injection:
- паттерн реализации;
- описывает, как объекты получают свои зависимости;
- способ передачи зависимости объекту извне, вместо создания их внутри объекта;
- цель - улучшить модульность и тестируемость кода.

Ключевые различия:
- Уровень абстракции:
	- Dependency Injection - конкретная техника реализации;
	- Dependency Inversion - высокоуровневый принцип проектирования.
- Область применения:
	- Dependency Injection - на уровне отдельных классов и объектов;
	- Dependency Inversion - применяется на уровне архитектуры приложения.
- Цель:
	- Dependency Injection - нацелен на улучшение гибкости и тестируемости кода;
	- Dependency Inversion - нацелен на уменьшение связанности между модулями.
- Реализация:
	- Dependency Injection - реализуется через конструкторы, сеттеры или интерфейсы внедрения;
	- Dependency Inversion - часто реализуется через использование интерфейсов или абстрактных классов.

Dependency Injection часто используется как способ реализации принципа Dependency Inversion, но это не единственный способ. Можно следовать принципу Dependency Inversion, не используя Dependency Injection, и наоборот.

*1.1) Замена в зависимости на интерфейс это уже Dependency Inversion?*

Нет, это понятие уходит за рамки использования интерфейсов.
В качестве абстракций можно использовать так же абстрактные классы или даже достаточно стабильные реализации (если они хорошо представляют собой высокоуровневую архитектуру).

Так же очень важно направление зависимостей, т.е. высокоуровневые модули определяют интерфейс, который реализуют  низкоуровневые модули (инверсия потока управления).

Абстракции должны быть стабильны и быть менее подвержены изменениям, чем детали реализации.

Существуют вполне конкретные реализации с использованием принципа DIP, такие как гексагональная архитектура и чистая архитектура.

*1.2) Передали в конструктор другой класс и это уже Dependency Inversion?*

Нет DI не ограничивается только передачей зависимостей в конструктор, можно передавать их через сеттеры, или прямо через свойства.

Многие фреймворки используют контейнеры DI для внедрения зависимостей.

IoC (Inversion of Control): Это общий принцип в программировании, где поток управления программы инвертируется по сравнению с традиционным процедурным программированием. В контексте управления зависимостями, IoC означает, что объект не создает или ищет свои зависимости самостоятельно, а вместо этого они предоставляются ему извне.

IoC контейнер (или DI контейнер): Это программный фреймворк или библиотека, которая реализует принцип IoC, автоматизируя процесс управления зависимостями объектов. Основные функции IoC контейнера:

- Регистрация типов и их зависимостей
- Разрешение зависимостей
- Управление жизненным циклом объектов
- Автоматическое внедрение зависимостей

*1.3) Подробно про Inversion of Control*

IoC (Inversion of Control): Это общий принцип в программировании, где поток управления программы инвертируется по сравнению с традиционным процедурным программированием. В контексте управления зависимостями, IoC означает, что объект не создает или ищет свои зависимости самостоятельно, а вместо этого они предоставляются ему извне.

IoC контейнер (или DI контейнер): Это программный фреймворк или библиотека, которая реализует принцип IoC, автоматизируя процесс управления зависимостями объектов. Основные функции IoC контейнера:

- Регистрация типов и их зависимостей
- Разрешение зависимостей
- Управление жизненным циклом объектов
- Автоматическое внедрение зависимостей

IoC контейнеры управляют созданием объектов и их зависимостями. Вот основные принципы их работы:

1. Регистрация типов:
    - Контейнер позволяет зарегистрировать типы (классы, интерфейсы) и правила их создания.
    - Это обычно делается через конфигурацию или программный код.
2. Разрешение зависимостей:
    - Когда запрашивается объект, контейнер анализирует его конструктор или другие места внедрения зависимостей.
    - Он рекурсивно создает и внедряет все необходимые зависимости.
3. Управление жизненным циклом:
    - Контейнер может управлять жизненным циклом объектов (например, синглтоны или транзиентные объекты).
4. Автоматическое связывание:
    - Многие контейнеры могут автоматически определять зависимости на основе типов параметров конструктора.
5. Поддержка различных типов внедрения:
    - Через конструктор, сеттер-методы, свойства.

2) **Зачем нужны итераторы, если я могу использовать массивы и просто создать функции, которые имитируют методы итератора?**

- Эффективность памяти: Итераторы позволяют работать с большими наборами данных без необходимости загружать все данные в память одновременно.
- Ленивые вычисления: Итераторы могут генерировать значения по мере необходимости, что полезно для работы с потенциально бесконечными последовательностями.
- Инкапсуляция: Итераторы скрывают детали реализации и предоставляют единый интерфейс для обхода различных структур данных.
- Совместимость: Многие встроенные функции и библиотеки PHP ожидают объекты, реализующие интерфейс Iterator.
- Читаемость кода: Использование стандартного интерфейса Iterator делает код более понятным и предсказуемым для других разработчиков.
- Гибкость: Итераторы позволяют легко изменять способ обхода данных без изменения кода, который их использует.
- Композиция: Итераторы можно комбинировать и объединять для создания сложных последовательностей данных.

3) **Что такое генераторы, зачем нужны, что возвращают.**

Генератор - конструкция языка php, которая предоставляет способ реализации простых итераторов без использования дополнительных ресурсов или сложностей, связанных с реализацией класса, использующего интерфейс Iterator.

По сути это однонаправленный, одноразовый итератор.

Для чего использовать:

Обработка больших файлов - чтение и обработка файла построчно, не загружая весь файл в память.
Пагинация данных из базы данных - извлечение данных из базы данных порциями для эффективной пагинации.
Генерация больших отчетов - создание отчета по частям, экономя память.

Функция-генератор возвращает объект типа Generator, который реализует интерфейсы `Iterator` и `Traversable`. Вот ключевые моменты:

1. Возвращаемое значение:
    - Когда вы вызываете функцию-генератор, она не выполняется немедленно.
    - Вместо этого она возвращает объект Generator.
2. Работа Generator:
    - Generator сохраняет состояние функции-генератора между вызовами.
    - Он позволяет приостанавливать выполнение функции и возобновлять его позже.
3. Ключевое слово yield:
    - Когда функция-генератор достигает оператора yield, она "выдает" значение и приостанавливает свое выполнение.
    - При следующем запросе значения, выполнение продолжается с места, где оно было приостановлено.
4. Использование:
    - Обычно генераторы используются в циклах (foreach) или вызываются вручную через методы Generator.

```php
function simpleGenerator() {
    yield 1;
    yield 2;
    yield 3;
}

$generator = simpleGenerator(); // Возвращает объект Generator

var_dump($generator); // object(Generator)#1

foreach ($generator as $value) {
    echo $value . "\n";
}
// Выводит:
// 1
// 2
// 3

// Альтернативное использование:
$generator = simpleGenerator();
echo $generator->current() . "\n"; // 1
$generator->next();
echo $generator->current() . "\n"; // 2
```

В этом примере:

1. `simpleGenerator()` возвращает объект Generator.
2. Цикл foreach автоматически использует методы Generator для итерации.
3. Мы также можем вручную управлять итерацией, используя методы Generator.

Преимущества такого подхода:

- Экономия памяти: значения генерируются по мере необходимости.
- Возможность работы с большими или бесконечными последовательностями.
- Простота создания итерируемых объектов.

Generator предоставляет несколько методов, включая:

- `current()`: возвращает текущее значение
- `key()`: возвращает текущий ключ
- `next()`: переходит к следующему элементу
- `rewind()`: сбрасывает итератор
- `valid()`: проверяет, есть ли еще элементы

Это позволяет гибко управлять процессом итерации и интегрировать генераторы в различные части кода.

4) **Где используется и для чего *Reflection*? **

PHP поставляется с полным API-интерфейсом отражения (*Reflection*), который добавляет возможность анализа классов, интерфейсов, функций, методов и расширений. Кроме того, *Reflection* предлагает способы получения комментариев к документам для функций, классов и методов.

Reflection в PHP - это мощный инструмент для анализа и работы с кодом во время выполнения программы. Он позволяет исследовать классы, методы, свойства и другие элементы кода динамически. Вот основные аспекты Reflection:

1. Основные классы Reflection:
    - ReflectionClass
    - ReflectionMethod
    - ReflectionProperty
    - ReflectionFunction
    - ReflectionParameter
2. Возможности Reflection:
    - Получение информации о классах, методах, свойствах
    - Вызов методов и доступ к свойствам динамически
    - Создание экземпляров классов
    - Анализ параметров функций и методов
    - Работа с аннотациями (атрибутами в PHP 8+).
3. Пример использования

```php
class MyClass {
    private $property = 'value';
    
    public function myMethod($param) {
        echo "Method called with: $param";
    }
}

$reflection = new ReflectionClass('MyClass');

// Получение информации о классе
echo $reflection->getName(); // MyClass

// Создание экземпляра
$instance = $reflection->newInstance();

// Вызов метода
$method = $reflection->getMethod('myMethod');
$method->invoke($instance, 'Hello');

// Доступ к приватному свойству
$property = $reflection->getProperty('property');
$property->setAccessible(true);
echo $property->getValue($instance); // value
```

4. Применение Reflection:
    - Автоматическое тестирование
    - Реализация плагинов и расширений
    - Создание ORM систем
    - Реализация внедрения зависимостей (Dependency Injection)
    - Сериализация/десериализация объектов
5. Преимущества:
    - Гибкость в работе с кодом
    - Возможность анализа и изменения поведения программы во время выполнения
    - Полезно для создания фреймворков и библиотек
6. Недостатки:
    - Может снижать производительность при неправильном использовании
    - Может нарушать инкапсуляцию
    - Усложняет код и может сделать его менее понятным
7. Рекомендации по использованию:
    - Использовать осторожно и только когда действительно необходимо
    - Помнить о возможных проблемах с безопасностью при работе с пользовательским вводом
    - Тщательно тестировать код, использующий Reflection

Подробнее о применении:

1. DI контейнер: можно автоматически разрешать зависимости при создании объектов.
```php
class Container {
    public function resolve($className) {
        $reflection = new ReflectionClass($className);
        
        if (!$reflection->isInstantiable()) {
            throw new Exception("Class $className is not instantiable");
        }
        
        $constructor = $reflection->getConstructor();
        if (null === $constructor) {
            return new $className;
        }
        
        $parameters = $constructor->getParameters();
        $dependencies = $this->getDependencies($parameters);
        
        return $reflection->newInstanceArgs($dependencies);
    }

    private function getDependencies($parameters) {
        $dependencies = [];
        foreach ($parameters as $parameter) {
            $dependency = $parameter->getClass();
            if ($dependency === null) {
                if ($parameter->isDefaultValueAvailable()) {
                    $dependencies[] = $parameter->getDefaultValue();
                } else {
                    throw new Exception("Can not resolve class dependency {$parameter->name}");
                }
            } else {
                $dependencies[] = $this->resolve($dependency->name);
            }
        }
        return $dependencies;
    }
}
```

2. Создание ORM: помогает автоматически составлять свойства объектов с полями БД.

```php
class SimpleORM {
    public function mapObjectToDatabase($object) {
        $reflection = new ReflectionClass($object);
        $properties = $reflection->getProperties();
        
        $data = [];
        foreach ($properties as $property) {
            $property->setAccessible(true);
            $data[$property->getName()] = $property->getValue($object);
        }
        
        return $data;
    }

    public function mapDatabaseToObject($data, $className) {
        $reflection = new ReflectionClass($className);
        $object = $reflection->newInstance();
        
        foreach ($data as $key => $value) {
            if ($reflection->hasProperty($key)) {
                $property = $reflection->getProperty($key);
                $property->setAccessible(true);
                $property->setValue($object, $value);
            }
        }
        
        return $object;
    }
}
```

3. Автоматическая сериализация/десериализация: Reflection может помочь в создании универсальных сериализаторов для объектов.

```php
class Serializer {
    public function serialize($object) {
        $reflection = new ReflectionClass($object);
        $properties = $reflection->getProperties();
        
        $data = [];
        foreach ($properties as $property) {
            $property->setAccessible(true);
            $data[$property->getName()] = $property->getValue($object);
        }
        
        return json_encode($data);
    }

    public function deserialize($json, $className) {
        $data = json_decode($json, true);
        $reflection = new ReflectionClass($className);
        $object = $reflection->newInstance();
        
        foreach ($data as $key => $value) {
            if ($reflection->hasProperty($key)) {
                $property = $reflection->getProperty($key);
                $property->setAccessible(true);
                $property->setValue($object, $value);
            }
        }
        
        return $object;
    }
}
```

5) **У нас есть таблица с одной колонкой, на ней индекс, как сделать запрос чтобы индекс не использовался?**

Существует несколько подходов.

1. Использование функции на indexed колонке:

```sql
SELECT * FROM table_name WHERE FUNCTION(indexed_column) = some_value;
```

Когда мы применяем функцию к индексированной колонке, СУБД не может напрямую использовать индекс, потому что индекс построен на основе исходных значений колонки, а не на результатах функции.

Например:

```sql
SELECT * FROM table_name WHERE UPPER(indexed_column) = 'SOME_VALUE';
```

Почему это работает:

- Индекс создан для оригинальных значений `indexed_column`;
- Функция `UPPER()` изменяет эти значения перед сравнением;
- СУБД должна применить `UPPER()` к каждой строке, что требует полного сканирования таблицы.

Исключения:

- Некоторые СУБД поддерживают функциональные индексы, которые могут обойти это ограничение.
- В некоторых случаях оптимизатор может быть достаточно умным, чтобы преобразовать условие и все же использовать индекс.


2. Использование операции LIKE с wildcard в начале:

```sql
SELECT * FROM table_name WHERE indexed_column LIKE '%value';
```

Почему это работает:

- Индексы эффективны для поиска префикса (начала строки);
- Символ `%` в начале паттерна означает, что любое количество символов может предшествовать 'value';
- СУБД вынуждена проверять каждую строку, так как 'value' может находиться в любом месте строки.

Исключения:

- Некоторые СУБД имеют специальные индексы (например, полнотекстовые), которые могут оптимизировать такие запросы.

3. Использование арифметической операции:

```sql
SELECT * FROM table_name WHERE indexed_column + 0 = some_value;
```

Почему это работает:

- Добавление 0 не меняет значение, но изменяет выражение;
- СУБД должна вычислить результат для каждой строки, что препятствует использованию индекса.

Исключения:

- Продвинутые оптимизаторы могут распознать, что `+ 0` не меняет значение, и все же использовать индекс.

4. Использование оператора OR с всегда истинным условием:

```sql
SELECT * FROM table_name WHERE indexed_column = some_value OR 1=1;
```

Почему это работает:

- Условие `1=1` всегда истинно, что делает весь `WHERE` оператор всегда истинным.
- СУБД часто отказывается от использования индекса, так как все строки всё равно будут выбраны.

Исключения:

- Некоторые современные оптимизаторы могут распознать и оптимизировать такой запрос.


5. Явное указание оптимизатору не использовать индекс (синтаксис может отличаться в зависимости от СУБД):

Для MySQL:

```sql
SELECT /*+ NO_INDEX(table_name index_name) */ * FROM table_name WHERE indexed_column = some_value;
```

Для Oracle:

```sql
SELECT /*+ NO_INDEX(table_name index_name) */ * FROM table_name WHERE indexed_column = some_value;
```


Для SQL Server:

```sql
SELECT * FROM table_name WITH (INDEX(0)) WHERE indexed_column = some_value;
```

Почему это работает:

- Это прямое указание оптимизатору запроса игнорировать индекс.
- СУБД будет следовать этой инструкции, даже если использование индекса было бы более эффективным.

Исключения:

- В некоторых случаях СУБД может проигнорировать эту подсказку, если она считает, что использование индекса критически важно для производительности.

6) **Чем транкейт тейбл отличается от дроп тейбл без условия?**

### TRUNCATE TABLE:

1. **Удаление структуры данных**: TRUNCATE фактически удаляет структуру данных, которая содержит данные таблицы. В большинстве СУБД это означает удаление или освобождение страниц данных, а не удаление отдельных строк.
2. **Пересоздание структуры**: После удаления данных TRUNCATE создает новую, пустую структуру для таблицы. Это похоже на пересоздание таблицы, но без изменения её схемы.
3. **Сброс метаданных**: TRUNCATE сбрасывает все метаданные таблицы, такие как счетчики автоинкремента, статистику и т.д.
4. **Освобождение пространства**: Пространство, занимаемое данными, немедленно освобождается и становится доступным для повторного использования.

### DELETE без условий:

1. **Удаление отдельных строк**: DELETE удаляет каждую строку по отдельности, даже если удаляются все строки.
2. **Сохранение структуры**: Структура данных таблицы остается неизменной. Страницы данных не удаляются, а просто помечаются как содержащие удаленные данные.
3. **Сохранение метаданных**: Метаданные таблицы, такие как счетчики автоинкремента, обычно не сбрасываются.
4. **Постепенное освобождение пространства**: Пространство, занимаемое удаленными данными, может не освобождаться немедленно, а переиспользоваться СУБД по мере необходимости.

## Последствия различий в механизмах:

1. **Производительность**: TRUNCATE работает быстрее именно потому, что он оперирует целыми страницами данных, а не отдельными строками.
2. **Использование журнала транзакций**: DELETE записывает в журнал информацию о каждой удаленной строке, TRUNCATE же записывает только информацию об удалении и пересоздании структуры данных.
3. **Возможность отката**: Поскольку TRUNCATE по сути пересоздает структуру данных, эта операция обычно не может быть откачена в рамках транзакции.
4. **Влияние на индексы**: При выполнении TRUNCATE индексы также очищаются и пересоздаются, что может быть более эффективно, чем удаление всех записей через DELETE.
5. **Фрагментация**: После TRUNCATE таблица не фрагментирована, тогда как после массового DELETE может потребоваться дефрагментация.

|Характеристика|TRUNCATE TABLE|DELETE без условий|
|---|---|---|
|Скорость|Обычно быстрее, особенно для больших таблиц|Медленнее, особенно для больших таблиц|
|Журналирование|Минимальное журналирование|Полное журналирование каждой удаленной строки|
|Транзакции|Нельзя откатить (в большинстве СУБД)|Можно откатить|
|Триггеры|Обычно не активирует триггеры|Активирует триггеры|
|AUTO_INCREMENT|Сбрасывает счетчик к начальному значению|Не влияет на счетчик AUTO_INCREMENT|
|WHERE условие|Не поддерживает|Поддерживает (хотя в данном случае не используется)|
|Права доступа|Требует прав на изменение структуры таблицы|Требует прав только на удаление данных|
|Влияние на связанные таблицы|Может нарушить ссылочную целостность|Соблюдает ограничения внешнего ключа|
|Использование места|Немедленно освобождает пространство|Может не освобождать пространство сразу|

7) **Как запустить скрипт чтобы запускался раз в 10 секунд**

Существует несколько способов